---
title: "操作系统真象还原笔记"
date: "2021-06-20"
tags: ["uCore", "天问之路"]
ShowToc: true
TocOpen: true
draft: false
---

### 01操作系统是是什么

**社会组织和人们之间的关系，正是操作系统和用户进程的关系**  

当人们想和远方的朋友说话时，虽然可以徒步走到亲朋好友身边再对其表达想说的话，但社会组织 已经给提供了邮局和电话，何必自己再大老远跑一趟呢。这就是操作系统（社会组织）提供的资源。两 个人想在一起生活，要不要一定先结婚呢？完全不用，领不领证都不会阻碍人们在一起生活，但是社会 组织为了方便人口管理做了额外约束。不领证的话，至少社会组织无法预测未来人口数量趋势，无法做 出宏观调控，甚至这是找到你家人的一种方法。这就如 Linux 系统中的内存管理，分别要记录哪些页是 Active，哪些是“脏页“。不记录不会影响程序执行，记录这些状态还不是为了更好地管理 内存。

### 03写操作系统，哪些需要我来做

操作系统是管理资源的软件，操作系统能做什么，取决于主机上硬件的功能。

写操作系统需要了解硬件，这些硬件提供了软件方面的接口，这样我们的操作系统通过软件（计算机指令〉就能够控制硬件。我们需要做的就是知道如何通过计算机指令来控制硬件，参考硬件手册这下少不了啦。    

### 04软件是如何访问硬件的

各种硬件适配设备，这就是 **IO 接口**。接口其实就是标准，大家生产出来的硬件按照这个标准工作就实现了通用。

访问外部硬件有两个方式。

 （1）**将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中**，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 lMB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。

(2)**外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递 给另一端的外设**，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看， 处处体现着分层。 于是问题来了，如何访问到 IO 接口呢，答案就是 IO 接口上面有一些寄存器，访问 IO 接口本质上就是 访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口 。 人家接口 电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。接口提供接口，哈哈，有意思。 不过这是人家的约定，没有约定就乱了，各干各的，大家都累，咱们只要遵循人家的规定就能访问成功。

### 05应用程序是什么，和操作系统是如何配合到一起的

应用程序和操作系统都是软件。 CPU 会将它们一视同仁，甚至， CPU 不知道自己在执行的程序是操作系统，还是一般应用软件， CPU 只知道去 CS: ip 寄存器中指向的内 存取指令井执行，它不知道什么是操作系统，也无需知道。

应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是编译 器。是编译器决定怎样解释某种关键字及某种语法。 语言只是编译器和大家的约定，只要写入这样的代码， 编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为，和语言无关，比如说 C 语言的 printf 函数，它的功能不是说一定要把字符打印到屏幕上，这要看编译器对这种关键字的处理。

编译器提供了一套库函数，库函数中又有封装的系统调用，这样的代码集合称之为运行库。 C 语言的 运行库称为 C 运行库，就是所谓的 CRT ( C Runtime Library ）。

**应用程序加上操作系统提供功能才算是完整的程序。**由于有了操作系统的支持，一些现成的东西己经摆 在那了，但这些是属于操作系统的，不是应用程序的，所以咱们平时所写的应用程序只是半成品，需要调用操作系统提供好的函数才能完整地做成一件事，而这个函数便是**系统调用**。

**用户态与内核态**是对 CPU 来讲的，是指 CPU 运行在用户态（特权 3 级）还是内核态（特权 0 级）， 很多人误以为是对用户进程来讲的。

 用户进程陷入内核态是指 ：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的 中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户代码 怎么可能在内核中存在，所以“用户态与内核态”是对 CPU 来说的。 

当应用程序陆入内核后，它自己已经下 CPU 了，以后发生的事，应用程序完全不知道，它的上下文环境己 经被保存到自己的 0 特权级技中了，那时在 CPU 上运行的程序己经是内核程序了。所以要清楚，内核代码并不 是成了应用程序的内核化身，操作系统是独立的部分，用户进程永远不会因为进入内核态而变身为操作系统了。

应用程序是通过系统调用来和操作系统配合完成某项功能的，有人可能会问：我写应用程序时从来没 写什么系统调用的代码啊。这是因为你用到的标准库帮你完成了这些事，库中提供的函数其实都已经封装 好了系统调用，你需要跟下代码才会看到 。 其实也可以跨过标准库直接执行系统调用，对于 Linux 系统来 说，直接嵌入汇编代码“ int 0x80”便可以直接执行系统调用，-当然要提前设置好系统调用子功能号，该子功能号用寄存器 eax存储。 

会不会有人又问，编译器怎么知道系统调用接口是什么，哈哈，您想啊，下载编译器时，是不是要选择系 统版本，编译器在设计时也要知道自己将来运行在哪个系统平台上，所以这都是和系统绑定好的，各个操作系 统都有自己的系统调用号，编译器厂商在代码中已经把宿主系统的系统调用号写死了，没什么神奇的。

### 06 为什么称陷入内核

如果把软件分层的话， 最外圈是应用程序，里面是操作系统，如图 0-1 所示 。 应用程序处于特权级 3，操作系统内核处于特权级 0。当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调 用。这样 CPU 便进入了内核态，也称管态 。 看图中凹下去的部分，是不 是有陆进去的感觉，这就是“陷入内核”。

![image-20210615210325917](https://www.kro1lsec.com:442/images/2021/06/21/20210621152154.png)

###  07内存访问为什么要分段

只要程序分了段，把整个段平移到任何位置后，段内的地址相对于段基址是不变的，无论段基址是多少，只要给出段内偏移地址， CPU 就能访问到正确的指令。于是加载用户 程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无 误地运行，因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址处的内存内容还是一样的，如图 0-3 所示。

<img src="https://www.kro1lsec.com:442/images/2021/06/21/20210621152158.png" alt="image-20210616151126317" style="zoom:50%;" />

**程序分段首先是为了重定位**。 偏移地址也要存入寄存器，而那时的寄存器是 16 位的，也就 是一个段最多可以访问到 64阻。而那时的内存再小也有 IMB, 改变段基址，由一个段变为另一个段，就像一个段在内存中飘移， 采用这种在内存中来回挪位置的方式可以访问到任意内存位直。程序分段又**是为了将大内存分成可以访问的小段**， 通过这样变通的方法便能够访问到所有内存了。

### 08 代码中为什么分为代码段，数据段？这和内存访问机制中的段是一回事吗

**内存分段指的是处理器为访问内存而采用的机制，称之为内存分段机制，程序分段是软件中人为逻辑划分的内存区域，它本身也是内存，所以处理器在访问该区域时，也会采用内存分段机制，用段寄存器指向该区域的起始地址。**

程序不是一定要分段才能运行的，分段只是为了使程序更加优美 。  

x86 平台的处理器是必须要用分段机制访问内存的，正因为如此，处理器才提供了段寄存器，用来指定待访 问的内存段起始地址。我们这里讨论的程序代码中的段（用 section 或 segment 来定义的段，不同汇编编译器提 供的关键字有所区别，功能是一样的）和内存访问机制中的段本质上是一回事。 在硬件的内存访问机制中，处理 器要用硬件一一段寄存器，指向软件一一程序代码中用 section 或 segment 以软件形式所定义的内存段。

分段是必然的，只是在平坦模型下，硬件段寄存器中指向的内存段为最大的 4GB ，而在多段模式下编 程，硬件段寄存器中指向的内存段大小不一 。

对于目前咱们 用高级语言编码来说，我们之所以不用关心如何将程序分段，正是由于编译器按平坦模型编译，而程序所 依赖的操作系统又采用了虚拟内存管理，即处理器的分页机制。像汇编这种低级语言允许程序员为 自 己的 程序分段，能够灵活地编排布局，这就属于人为将程序分成段了，也就是采用多段模型编程 。

将数据和代码分开的好处有三点。 

第一，可以为它们赋予不同的属性。

 例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。真要是运行过程中程序的下一条指令被修改了，谁知道会产生什么样的灾难。

 第二，为了提高 CPU 内部缓存的命中率。

缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令 和数据分离，这有利于增强程序的局部性。 CPU 内部有针对数据和针对指令的两种缓存机制，因此，将 数据和代码分开存储将使程序运行得更快。 

第三，节省内存。

 程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时（比如同时执行多个 ls 命令时），没必要在内存中同时存在多个相同的代码段，这将浪费有限的物理内存资源，只要把这一个代 码段共享就可以了。

在保护模式下，有这样一个数据结构，它叫全局描述符表（ Global Descriptor Table, GDT），这个表中的每一项称为段描述符。先递归学习一下，什么是描述符？描述符就是描 述某种数据的数据结构，是元信息，属于数据的数据。就像人们的身份证，上面有写性别、出生日期、地址等 描述个人情况的信息。在段描述符中有段的属性位，在以后的章节中可以看到，其实是有 2 个，一个是 S 宇 段，占 1bit 大小，另外一个是占 4bit 大小的 TYPE 宇段，这两个宇段配合在一起使用就能组合出各种属性， 如只读、向下扩展、只执行等。提供归提供，可得有人去填写这张表啊，谁来做这事呢，有请操作系统登场。 接着看操作系统为我们做了什么。

 操作系统在让 CPU 进入保护模式之前，首先要准备好 GDT，也就是要设置好 GDT 的相关项，填写好 段描述符。段描述符填写成什么样，段具备什么样的属性，这完全取决于操作系统了，在这里大家只要知道， 段描述符中的 S 宇段和 TYPE 宇段负责该段的属性，也就是该属性与安全相关。 

（1）编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的 代码段和可写属性的数据段。再补充一下，编译器并没有让段具备某种属性，对于代码段，编译器所做的 只是将代码归类到一起而己，也就是将程序中的有关代码的多个 section 合并成一个大的 segment （这就是 我们所说的代码段〉，它并没有为代码段添加额外的信息。

(2 ）操作系统通过设置 GOT 全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属 性（包括 S 宇段和 TYPE 字段）。也就是说，操作系统认为代码应该是只读的，所以给用来指向代码段的 那个段描述符设置了只读的属性，这才是真正给段添加属性的地方。 

(3) CPU 中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其 理解为相当于段基址〉，从而确定了指向的段。在执行指令时，会根据该段的属性来判断指令的行为，若 有返回则发出异常。 总之，编译器、操作系统、 CPU 三个配合在一起才能对程序保护，检测出指令中的违规行为。如果 GDT 中的代码段描述符具备可写的属性，那编译器再怎么划分代码段都没有用，有判断权利的只有 CPU 。

**编译器编译出来的段和内存访问中的段是一回事吗？**  

程序中的段只是逻辑上的划分，用于不同数据的归类， 但是可以用 CPU 中的段寄存器直接指向它们，然后用内存分段机制去访问程序中的段，在这一点上看，它们很像相片和相框的关系：程序中的段是内存中的内容，相当于相片，属于被展示的内容，而内存分段机制则是访问内存的手段，相当于相框，有了相框，照片才能有地摆放 。  

### 09物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

**物理地址就是物理内存真正的地址**，具有唯一性。不管在什么模式下， 不管什么虚拟地址、线性地址， CPU 最终都要以物理地址去访问内存。

在**实模式**下，“段基址＋段内偏移地址”经过段部件的处理，直接输出的就是物理地址， CPU 可以直接用此地址访问内存 。

 而在**保护模式**下，＂段基址＋段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址 了，而是一个称为选择子的东西 。 它本质是个索引，类似于数组下标，通过这个索引便能在 GDT 中找到相应 的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能， 此线性地址就被当作物理地址来用，可直接访问内存。 若开启了分页功能，此**线性地址**又多了一个名字，就是 **虚拟地址** （虚拟地址、线性地址在分页机制下都是一回事） 。 虚拟地址要经过 CPU 页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线去访问内存。 无论在实模式或是保护模式下，**段内偏移地址又称为有效地址，也称为逻辑地址**，这是程序员可见的地址 。 这是因为，最终的地址是由段基址和段内偏移地址组合而成的。由于段基址已经有默认的啦，要么是在实模式下的默认段寄存器中，要么是在保护模式下的默认段选择子寄存器指向的段描述 符中，所以只要给出段内偏移地址就行了，这个地址虽然只是段内偏移，但加上默认的段基址，依然足够有效 。 

线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间 。 由于分页功能是需要在保护模式下开启的， 32 位系统保护模式下的寻址空间是 4GB，所以虚拟地址或线性地 址就是 0～4GB 的范围 。 转换过程如图 0-5 所示 。

![image-20210616154921006](https://www.kro1lsec.com:442/images/2021/06/21/20210621152205.png)

### 10什么是段重叠

假设在实模式下（并不是说在保护模式下就不存在段重叠，只是这样就会少解释了相关数据结构， 如段描述符，不过这不重要，原理是一样的）， 一个段最大为 64kb，其大小由段内偏移地址寻址范围决定， 也就是 2 的 16 次方 。 其起始位置由段基地址决定。 **CPU 的内存寻址方式**是：给我一个段基址，再给我一 个相对于该段起始位置的偏移地址，我就能访问到相应内存 。 它并不要求一个内存地址只隶属于某一个段，所以在上面的 图 0-2 中，欲访问内存 0xC03 ，段基址可以选择 0xC00, 0xC01, 0xC02, 0xC03 ，只不过是段内偏移量要根据段基地址来调整罢了 。 用这种“段基地址：段内偏移”的组合， 0xC00: 3 和 0xC02: 1 是等价的，它们都访问到同一个物理内存块 。 但段的大小决定于段内偏移地址寻址范围，假设段 A 的段基址是 从 0xC00开始，段 B 的段基址是从 0xC02 开始，在 16 位宽 段A 度的寻址范围内，这两个段都能访问到 0xC05 这块内存。用 段 A 去访问，其偏移为 5，用段 B 去访问，其偏移量为 3 。 这样一来，用段 B 和段 A 在地址 OxC02 之后， 一直到段 B 偏移地址为 0xfffe 的部分，像是重叠在一起了，这就是段重叠了，如图 0-6 所示 。

![image-20210616155642795](https://www.kro1lsec.com:442/images/2021/06/21/20210621152210.png)

### 11什么是平坦模型

平坦模型是相对于多段模型来说的，所以说平坦模型指的就是一个段 。   

### 12cs、ds、这类srog段寄存器，位宽是多少

 在 32 位 CPU 中，**sreg 段寄存器都是 16 位宽**。

CPU 中存在段寄存器是因为其内存是分段访问的。

CPU 内部的段寄存器（ Segment reg ）如下。
(1) CS - 代码段寄存器（ Code Segment Register），其值为代码段的段基值 。  

(2) DS - 数据段寄存器（ Data Segment Register），其值为数据段的段基值。
(3) ES－附加段寄存器（ Extra Segment Register），其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。
(4) FS - 附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，同上，用途不固定，使用上灵活机动。
(5) GS - 附加段寄存器（ Extra Segment Register），其值为附加数据段的段基值。
(6) SS - 堆栈段寄存器（ Stack Segment Register），其值为堆栈段的段值。  

32 位 CPU 有两种不同的工作模式：实模式和保护模式。 

每种模式下，段寄存器中值的意义是不同的，但不管其为何值，在段寄存器中所表达的都是指向的段在哪里。在实模式下， cs 、 DS 、 ES 、 SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子” C Selector), 当然，选择子也是数值，其依然为 16 位宽度。 

可见，在 32 位 CPU 中， sreg 无论是工作在 16 位的实模式，还是 32 位的保护模式，用的段寄存器都 是同一组，并且在 32 位下的段选择子是 16 位宽度，排除了段寄存器在 32 位环境下是 32 位宽的可能，综上所述， sreg 都是 16 位宽。

### 13什么是工程，什么是协议

软件中的工程是指开发一套软件所需要的全部文件，包含实际代码和环境配置。

协议是一种大家共同遵守的规约，主要用来实现通信、共享、协作：起初是为避免大家各干各的，无法彼此调用对方成果的情况，从而给大家统一一种接口、一组数据调用或者分析的约定。  

### 14为什么Linux下的应用程序不能在Windows下运行

- **格式不同**

  Linux 下的可执行程序格式是 elf （Executable and Linking Format  ）

  ​	Windows 下的可执行程序是 PE 格式（ portable executable，可移植的可执行文件）  				

- **系统API不同**

  Linux 中的可执行程序获得系统资源的方法和 Windows 不一样。

  Linux 中的 API 称为系统调用，是通过 int 0x80。这个软中断实现的。

  而 Windows 中的 API 是存放在动态链接库文件（ DLL，Dynamic Link Library）中。DLL 是 一个库，里面包含代码和数据，可供用户程序调用， DLL 不是可执行文件，不能够单独运行。

- 除以上原因外，还和**编译器**、**标准库**有关，不再列举。  

### 15局部变量和函数参数为什么要放在栈中

**全局变量**：意味着谁都可以随时随地访问，所以其放在数据段中。

**局部变量**：只是自己在用，放在数据段中纯属琅费空间，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。这个就是**堆栈框架**，提到了就说一点吧，栈由于是向下生长的，堆栈框架就是把 esp 指针提前加一个数，原 esp 指针到新 esp 指针之间的栈空间用来存储局部变量。

解释一个概念，堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程 规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。

堆是堆，而堆栈就是栈，和堆没关系，只是都这么叫。栈和堆栈都是指的栈，在 C程序的内存布局中，由于 堆和栈的地址空间是接壤的，栈从高地址往低地址发展，堆是从低地址往高地址发展，堆和栈早晚会碰头，它们各自的大小取决于实际的使用情况，界限并不明朗，所以这可能是堆栈常放在一直称呼的原因吧。

**函数参数为什么会放到栈区呢**？

第一也是其局部性导致的，只有这个函数用这个参数，何必将其放在数据段呢 。

第二 ，因为函数是在程序执行过程中调用的，属于动态的调用，编译时无法预测会何时调用及被调用的次数，函数的参数及返回值都需要内存来存储，不知道需要多少内存 。即使编译器可以预测，那提前准备好内存也是一种浪费。所以编译器选择在每次调用函数时才为它在栈中分配内存。  

### 16为什么说汇编语言比C语言快

首先说这是谬论，汇编语言编译器编译出来的机器指令和 C 编译器编译出来的机器指令无异。  

但高级语言如 C 语言为了通用性等，加入了一些额外的代码， 因此编译出来的汇编代码比较多，不如用汇编语言直接 写功能相关的部分效果来得更直接， C 语言被编译成机器指令后， 相当于多执行了一些“看似没用”的指令，因此会比直接用汇编语言慢。