---
title: "[工具]Ollydbg"
date: 2021-03-10T15:07:34+08:00
draft: false
---

### 简介

![img](https://www.kro1lsec.com:442/images/2021/05/28/20210528170835.png)

![img](https://www.kro1lsec.com:442/images/2021/05/28/20210528170840.png)



### **快捷键**

- `Ctrl`+`F1`：打开与所选行内符号相关的 API 帮助文档。
- `F2`：在光标选定位置按 F2 键设置或取消断点。
- `Shift`+`F2`：在首个选择命令设置条件断点。
- `Ctrl`+`F2`：重新启动被调试程序。
- `F4`：运行到光标选定位置处暂停。
- `Shift`+`F4`：设置记录断点。
- `F5`：最大化当前窗口。
- `Ctrl`+`F5`：打开与首个选择的命令相对应的源文件。
- `Alt`+`F5`：让 OllyDbg 窗口总在最前面。
- `F6`：切换到下一个窗口。
- `Shift`+`F6`：切换到前一个窗口。
- `F7`：单步步入：每次执行一条指令，遇到 call 等子程序时进入其中。
- `Shift`+`F7`：与 F7 相同，但当被调试程序发生异常而中止时，调试器首先尝试步入被调试程序指定的异常处理。
- `Ctrl`+`F7`：自动步入，在所有的函数调用中一条一条地执行命令。
- `Alt`+`F7`：转到上一个找到的参考。
- `F8`：单步步过，每次执行一条指令，遇到 call 等子程序时不进入其中。
- `Shift`+`F8`：与 F8 相同，但当被调试程序发生异常而中止时，调试器首先尝试步过被调试程序指定的异常处理。
- `Ctrl`+`F8`：自动步过，一条一条执行命令，但不进入函数内部调用。
- `Alt`+`F8`：转到下一个找到的参考。
- `F9`：运行，被调试软件继续运行，直到遇到下一个断点。
- `Shift`+`F9`：与 F9 相同，但当被调试程序发生异常而中止时，调试器首先尝试执行被调试程序指定的异常处理。
- `Ctrl`+`F9`：执行到返回，在执行到一个 ret 指令时暂停，常用于从当前函数快速返回到上一个函数。
- `Alt`+`F9`：执行到用户代码，可用于从系统部分快速返回到被调试程序部分。
- `F10`：打开与当前窗口或面板相关的快捷菜单。
- `Ctrl`+`F11`：Run 跟踪步入，一条一条执行命令，进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。
- `F12`：停止执行，暂停所有线程。
- `Ctrl`+`F12`：Run 跟踪步过，一条一条执行命令，不进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。
- `Alt`+`F3`：关闭当前窗口。
- `Alt`+`B`：显示断点窗口。
- `Alt`+`C`：显示 CPU 窗口。
- `Alt`+`E`：显示模块列表。
- `Alt`+`K`：显示调用栈。
- `Alt`+`L`：显示日志窗口。
- `Alt`+`M`：显示内存窗口。
- `Alt`+`O`：显示选项对话框。
- `Alt`+`Backspace`：撤销对所选部分的修改。
- `Ctrl`+`A`：分析当前模块的代码段。
- `Ctrl`+`B`：开始二进制搜索。
- `Ctrl`+`E`：以十六进制格式编辑所选内容。
- `Ctrl`+`F`：开始命令搜索。
- `Ctrl`+`G`：转到某地址。
- `Ctrl`+`J`：列出所有的涉及到该位置的调用和跳转。
- `Ctrl`+`K`：查看与当前函数相关的调用树。
- `Ctrl`+`L`：搜索下一个。
- `Ctrl`+`N`：打开当前模块的名称列表。
- `Ctrl`+`O`：扫描对象文件。
- `Ctrl`+`P`：显示补丁窗口。
- `Ctrl`+`R`：搜索所选命令的参考。
- `Ctrl`+`S`：命令搜索。
- `Ctrl`+`T`：打开“暂停Run跟踪”对话框。
- `Esc`：停止自动执行或跟踪。
- `Enter`：将选中的命令添加到命令历史，如果当前命令是一个跳转或者函数，则进入到目的地址。
- `Backspace`：如果分析器将代码误识为数据，可以将选中部分的自动分析信息移除。
- *：转到原始位置
- `Ctrl`+`*`：指定新的起始位置。
- `+`：如果 Run 跟踪没有激活，则根据历史命令跳到下一条运行过命令的地方；否则跳到 Run 跟踪的下一个记录。
- `Ctrl`+`+`：跳到前一个函数的开始处。
- `-`：如果 Run 跟踪没有激活，则根据历史命令跳到前一条运行过命令的地方；否则跳到 Run 跟踪的前一个记录。
- `Ctrl`+`-`：跳到下一个函数的开始处。
- `Space`：修改命令。
- `:`：添加标签。
- `;`：添加注释。

-（减号）：回看之前单步跟踪的代码

Ctrl + F9: 当位于某个call指令中，想返回调用这个call指令的位置

Ctrl + F2：重新加载程序

F12：暂停（死循环）

Alt + B：打开断点窗口，del键删除

Ctrl + G:打开跟随表达式窗口（区分大小写）也可用于跳转地址

Alt + F9： 回到调用函数的地方

### 再探 OD

mov [local.1]，eax

[local.1] 局部变量 1

[arg-1] 参数 1

#### 实战的坑

##### OD 的 BUG

od 的汉化版和插件可能会出现坑，可以考虑改用 x64/32dbg。

可以下**内存访问**断点，一般都能**硬件断点**。

如果不行，1. 调试器有问题 2. 软件 nb

###### od 假死

t ：线程 突然暂停，恢复即可

###### Ctrl+g 插件 bug

（.IDAFicator.dll）：硬件断点重启后才会生效（正常情况直接生效）

**vs 编译会生成很多 jmp**，叫增量链接（节省源码小改动，重新生成程序的时间），链接器中可以去掉

#### 常用操作

查找所有命令

可以找到所有调用该命令的地方，（感觉类似交叉引用）

##### 搜索下一个

Ctrl+l

##### 模糊查找

ctrl + b 未知的值用?? 代替

E8 E0 E9 ?? ?? ?? ?? E8

##### 条件断点

**shift+f12** [esp+4]!=00290642 中文版 od 可能会自动加一些奇怪的东西，可以切换成英文的调试

##### 自动步过

Ctrl + F8

##### 走到这个函数的返回

Ctrl+F9

##### 回退上一步

**-**

##### 查看程序调用堆栈

**k** 通过 dbghelp.del 打印堆栈

最上面的堆栈离当前位置最近，从下到上依次执行。用 vs 可以看堆栈的情况

##### 查看程序的所有模块

**e** 可用于查询基地址

##### 内存窗口

**m** 可用于搜索字符串，在智能搜索中找不到的，这里没准能找到

##### 数据窗口

选择数据窗口 ctrl+e （右键 >> 二进制 >> 编辑）在 ascll 界面输入 “注册失败”，复制 hex 数据

即可打印：注册失败

定义成局部变量，编译器 >> 写入代码段，od 无法识别成字符串。（防止 re 小白通过字符串查找，直接定位到关键代码）

定义成全局变量：编译器 >> 以字符串形式写入 data 段。

od 可以识别成字符串

##### 查找二进制字符串：

在数据窗口中

ctrl+b

ctrl+l 下一个

#### 实战技巧

##### 加壳程序字符串搜索

跑起来之后，m 窗口。代码节开始搜索

标题提示字符串 setwindowTextA

##### 硬件 HOOK

进程：不能运行，必须依靠线程运行 宿主

线程： 寄宿者

线程上下文：context

EIP：指向下一条需要执行的代码

调试寄存器：

DR0~DR7

DR7：老大。的其他 DR 里的值是否生效，由 DR7 决定。

**硬件断点：**下断点后，调试寄存器保存地址，程序执行时读取 DR 寄存器，代码报错，OD 接管

特点：重启不会消失

**crc 检测：**程序在任意地方下断点，程序马上死机

或者全代码校验：另开一个线程，不断计算关键位置的值。

绕过方法：t 线程窗口，观察哪个线程一直在运行，挂起即可。

不修改代码

jnz，看 z 标志寄存器，直接改标志寄存器，能够直接在不修改代码的情况下暴力破解。

##### EWND 插件

定位易语言窗口, 修改窗口 ID，实现绕过登录窗口，直接加载程序主窗口（push ）

插件原理：找到易语言体（FF25) 的位置，将 push 指令改为插件枚举到的窗口地址

##### IMMLABLE 插件

**利用 immlable 插件重命名 call 调用的函数**

![image-20201116103252525](https://www.kro1lsec.com:442/images/2021/05/28/20210528171119.png)

因为程序执行的时候可能会反复调用同一个函数，重命名之后方便定位关键点，分析程序逻辑。

**插件原理：**跟进 call 函数调用的地址（ctrl+g）加标签 新名字即可

**标签：**给地址取别名。反汇编窗口快捷键 :

##### STRONG OD 插件

可在程序开始时定位到 TLS 函数位置

```c++
NtQueryInformationThread(GetCurrentThread(),ThreadHideFromDebugger,0,0);//不接受内核调试信息
NtQueryInformationProcess(GetCurrentProcess(),ProcessDebugPort,(PVOID)&isDebug,size(DWORD),&isDebug); //查询调试端口
```

在 32 位条件下把 & isDebug 返回值改为 0

##### 脚本编写

运用插件：ODbgScript

脚本示例：

```shell
//隐藏调试器
dbh
//从Eip的位置查找第一个特征码
find eip, #E80000000081042417000000C3576174636820757220737465702100#
//判断是否找到
cmp $RESULT,0
//如果没找到就跳出到结束
je exit
//如果找到就填充成NOP
mov [$RESULT], #90909090909090909090909090909090909090909090909090909090#
//从Eip的位置查找下一一个特征码
find eip, #E80000000081042425000000C354686520666C616720626567696E7320776974682022666C61677B2200#
//判断是否找到
cmp $RESULT, 0
//没找到就退出
je exit.
//找到就填充为NOP
mov [$RESULT], #909090909090909090909090909090909090909090909090909090909090909090909090909090909090#
//定义一个循环的标签,因为下面这个特征码不止一处,所以需要循环多次进行查找
loop:
  //从Eip的位置查找
  find. eip, #E801000000?????????C3#
  //判断是否找到
  cmp $RESULT,O
  //如果找不到了就退出
  je. exit
  //找到就填充为90
  mov
  [$RESULT], #9090909090909090909090#
  //继续循环
jmp loop
exit:
MSG”花指令已去除完毕! \r\n Code By:谅游浅笔深画眉/ NCK"
ret
```

##### ALT+K 暂停法

a、如何操作 b、暂停法原理，理解调用堆栈。 调用堆栈究竟是什么东西。 调用堆栈是如何被记录的。 调用堆栈的记录顺序。

**k** 查看程序调用堆栈 通过 dbghelp.del 打印堆栈

##### 自动跟踪法

适用于寻找控制台程序的入口点

调试 -- 自动步过停到 call 指令，下断点，F7 进去, 再自动步过，删刚刚的断点，下新断点。

##### IDA&OD 查找字符串原理

为什么 od 搜不到的字符串，ida 能搜到

od 智能搜索原理：遍历数据窗口的 16 进制数，如果为 00 结尾，则前面的就是字符串。缺陷：无法搜索到结构体

ida 静态搜索 pe 文件

##### 易语言多线程特征

根据正常操作流程，ctrl+g 寻找 messgaeBox ，f8 一直跟进发现：

双击过去

可见 je..jmp 关键跳

##### 壳的特征

大多数加壳的软件拖到 od 会有提示，其次是运行前汇编很奇怪，运行时会还原真实代码。

##### DLL 劫持

软件加载有就近原则，默认去系统目录下加载 dll，如果根目录下有 dll 文件，则优先加载。将修改过的 dll 放入根目录即可实现 dll 劫持。

**加壳软件的 dll 劫持**

需要在正确的时间，dll 劫持

方法：

另开线程延时启动（不靠谱）

判断解密是否完成（判断某个地址的指令是否等于脱壳后的）

hookAPI（还没学）

##### 2.13TRACEME 复现

![img](https://www.kro1lsec.com:442/images/2021/05/28/20210528171042.png)

1.找到关键 API，这样能快速锁定核心代码的区域。

GetDlgItemTextA

2.alt+F9，找到调用函数的地址，F2. F9 跑一下

加密与解密中很详细地写了 **GetDlgItemTextA** 的核心和分析过程，我就不班门弄斧了。接下来用爆破法，修改 004011F5 为 nop，ZF 寄存器改为 1，保存即可。新程序输入任意值都可注册成功。

# **参考资料**

- http://www.ollydbg.de/

- https://firmianay.gitbook.io/ctf-all-in-one/2_tools/dong-tai-fen-xi-gong-ju/2.3.2_ollydbg#参考资料)