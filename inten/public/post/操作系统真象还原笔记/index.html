<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>操作系统真象还原笔记 | intenのblog🍦</title><meta name=keywords content="uCore,天问之路"><meta name=description content="01操作系统是是什么 社会组织和人们之间的关系，正是操作系统和用户进程的关系
当人们想和远方的朋友说话时，虽然可以徒步走到亲朋好友身边再对其表达想说的话，但社会组织 已经给提供了邮局和电话，何必自己再大老远跑一趟呢。这就是操作系统（社会组织）提供的资源。两 个人想在一起生活，要不要一定先结婚呢？完全不用，领不领证都不会阻碍人们在一起生活，但是社会 组织为了方便人口管理做了额外约束。不领证的话，至少社会组织无法预测未来人口数量趋势，无法做 出宏观调控，甚至这是找到你家人的一种方法。这就如 Linux 系统中的内存管理，分别要记录哪些页是 Active，哪些是“脏页“。不记录不会影响程序执行，记录这些状态还不是为了更好地管理 内存。
03写操作系统，哪些需要我来做 操作系统是管理资源的软件，操作系统能做什么，取决于主机上硬件的功能。
写操作系统需要了解硬件，这些硬件提供了软件方面的接口，这样我们的操作系统通过软件（计算机指令〉就能够控制硬件。我们需要做的就是知道如何通过计算机指令来控制硬件，参考硬件手册这下少不了啦。
04软件是如何访问硬件的 各种硬件适配设备，这就是 IO 接口。接口其实就是标准，大家生产出来的硬件按照这个标准工作就实现了通用。
访问外部硬件有两个方式。
（1）将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 lMB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。
(2)外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递 给另一端的外设，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看， 处处体现着分层。 于是问题来了，如何访问到 IO 接口呢，答案就是 IO 接口上面有一些寄存器，访问 IO 接口本质上就是 访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口 。 人家接口 电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。接口提供接口，哈哈，有意思。 不过这是人家的约定，没有约定就乱了，各干各的，大家都累，咱们只要遵循人家的规定就能访问成功。
05应用程序是什么，和操作系统是如何配合到一起的 应用程序和操作系统都是软件。 CPU 会将它们一视同仁，甚至， CPU 不知道自己在执行的程序是操作系统，还是一般应用软件， CPU 只知道去 CS: ip 寄存器中指向的内 存取指令井执行，它不知道什么是操作系统，也无需知道。"><meta name=author content><link rel=canonical href=https://1nten.github.io//post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.min.84cc6e7cd97516a4d4e877c6bebe5a4529afdf61f4d009e2c8bbec3a876fff4e.css integrity="sha256-hMxufNl1FqTU6HfGvr5aRSmv32H00AniyLvsOodv/04=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://1nten.github.io//favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://1nten.github.io//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://1nten.github.io//favicon-32x32.png><link rel=apple-touch-icon href=https://1nten.github.io//apple-touch-icon.png><link rel=mask-icon href=https://1nten.github.io//safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><meta property="og:title" content="操作系统真象还原笔记"><meta property="og:description" content="01操作系统是是什么 社会组织和人们之间的关系，正是操作系统和用户进程的关系
当人们想和远方的朋友说话时，虽然可以徒步走到亲朋好友身边再对其表达想说的话，但社会组织 已经给提供了邮局和电话，何必自己再大老远跑一趟呢。这就是操作系统（社会组织）提供的资源。两 个人想在一起生活，要不要一定先结婚呢？完全不用，领不领证都不会阻碍人们在一起生活，但是社会 组织为了方便人口管理做了额外约束。不领证的话，至少社会组织无法预测未来人口数量趋势，无法做 出宏观调控，甚至这是找到你家人的一种方法。这就如 Linux 系统中的内存管理，分别要记录哪些页是 Active，哪些是“脏页“。不记录不会影响程序执行，记录这些状态还不是为了更好地管理 内存。
03写操作系统，哪些需要我来做 操作系统是管理资源的软件，操作系统能做什么，取决于主机上硬件的功能。
写操作系统需要了解硬件，这些硬件提供了软件方面的接口，这样我们的操作系统通过软件（计算机指令〉就能够控制硬件。我们需要做的就是知道如何通过计算机指令来控制硬件，参考硬件手册这下少不了啦。
04软件是如何访问硬件的 各种硬件适配设备，这就是 IO 接口。接口其实就是标准，大家生产出来的硬件按照这个标准工作就实现了通用。
访问外部硬件有两个方式。
（1）将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 lMB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。
(2)外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递 给另一端的外设，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看， 处处体现着分层。 于是问题来了，如何访问到 IO 接口呢，答案就是 IO 接口上面有一些寄存器，访问 IO 接口本质上就是 访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口 。 人家接口 电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。接口提供接口，哈哈，有意思。 不过这是人家的约定，没有约定就乱了，各干各的，大家都累，咱们只要遵循人家的规定就能访问成功。
05应用程序是什么，和操作系统是如何配合到一起的 应用程序和操作系统都是软件。 CPU 会将它们一视同仁，甚至， CPU 不知道自己在执行的程序是操作系统，还是一般应用软件， CPU 只知道去 CS: ip 寄存器中指向的内 存取指令井执行，它不知道什么是操作系统，也无需知道。"><meta property="og:type" content="article"><meta property="og:url" content="https://1nten.github.io//post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%94%E8%AE%B0/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-06-20T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="操作系统真象还原笔记"><meta name=twitter:description content="01操作系统是是什么 社会组织和人们之间的关系，正是操作系统和用户进程的关系
当人们想和远方的朋友说话时，虽然可以徒步走到亲朋好友身边再对其表达想说的话，但社会组织 已经给提供了邮局和电话，何必自己再大老远跑一趟呢。这就是操作系统（社会组织）提供的资源。两 个人想在一起生活，要不要一定先结婚呢？完全不用，领不领证都不会阻碍人们在一起生活，但是社会 组织为了方便人口管理做了额外约束。不领证的话，至少社会组织无法预测未来人口数量趋势，无法做 出宏观调控，甚至这是找到你家人的一种方法。这就如 Linux 系统中的内存管理，分别要记录哪些页是 Active，哪些是“脏页“。不记录不会影响程序执行，记录这些状态还不是为了更好地管理 内存。
03写操作系统，哪些需要我来做 操作系统是管理资源的软件，操作系统能做什么，取决于主机上硬件的功能。
写操作系统需要了解硬件，这些硬件提供了软件方面的接口，这样我们的操作系统通过软件（计算机指令〉就能够控制硬件。我们需要做的就是知道如何通过计算机指令来控制硬件，参考硬件手册这下少不了啦。
04软件是如何访问硬件的 各种硬件适配设备，这就是 IO 接口。接口其实就是标准，大家生产出来的硬件按照这个标准工作就实现了通用。
访问外部硬件有两个方式。
（1）将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 lMB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。
(2)外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递 给另一端的外设，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看， 处处体现着分层。 于是问题来了，如何访问到 IO 接口呢，答案就是 IO 接口上面有一些寄存器，访问 IO 接口本质上就是 访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口 。 人家接口 电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。接口提供接口，哈哈，有意思。 不过这是人家的约定，没有约定就乱了，各干各的，大家都累，咱们只要遵循人家的规定就能访问成功。
05应用程序是什么，和操作系统是如何配合到一起的 应用程序和操作系统都是软件。 CPU 会将它们一视同仁，甚至， CPU 不知道自己在执行的程序是操作系统，还是一般应用软件， CPU 只知道去 CS: ip 寄存器中指向的内 存取指令井执行，它不知道什么是操作系统，也无需知道。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://1nten.github.io//post/"},{"@type":"ListItem","position":2,"name":"操作系统真象还原笔记","item":"https://1nten.github.io//post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"操作系统真象还原笔记","name":"操作系统真象还原笔记","description":"01操作系统是是什么 社会组织和人们之间的关系，正是操作系统和用户进程的关系\n当人们想和远方的朋友说话时，虽然可以徒步走到亲朋好友身边再对其表达想说的话，但社会组织 已经给提供了邮局和电话，何必自己再大老远跑一趟呢。这就是操作系统（社会组织）提供的资源。两 个人想在一起生活，要不要一定先结婚呢？完全不用，领不领证都不会阻碍人们在一起生活，但是社会 组织为了方便人口管理做了额外约束。不领证的话，至少社会组织无法预测未来人口数量趋势，无法做 出宏观调控，甚至这是找到你家人的一种方法。这就如 Linux 系统中的内存管理，分别要记录哪些页是 Active，哪些是“脏页“。不记录不会影响程序执行，记录这些状态还不是为了更好地管理 内存。\n03写操作系统，哪些需要我来做 操作系统是管理资源的软件，操作系统能做什么，取决于主机上硬件的功能。\n写操作系统需要了解硬件，这些硬件提供了软件方面的接口，这样我们的操作系统通过软件（计算机指令〉就能够控制硬件。我们需要做的就是知道如何通过计算机指令来控制硬件，参考硬件手册这下少不了啦。\n04软件是如何访问硬件的 各种硬件适配设备，这就是 IO 接口。接口其实就是标准，大家生产出来的硬件按照这个标准工作就实现了通用。\n访问外部硬件有两个方式。\n（1）将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 lMB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。\n(2)外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递 给另一端的外设，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看， 处处体现着分层。 于是问题来了，如何访问到 IO 接口呢，答案就是 IO 接口上面有一些寄存器，访问 IO 接口本质上就是 访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口 。 人家接口 电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。接口提供接口，哈哈，有意思。 不过这是人家的约定，没有约定就乱了，各干各的，大家都累，咱们只要遵循人家的规定就能访问成功。\n05应用程序是什么，和操作系统是如何配合到一起的 应用程序和操作系统都是软件。 CPU 会将它们一视同仁，甚至， CPU 不知道自己在执行的程序是操作系统，还是一般应用软件， CPU 只知道去 CS: ip 寄存器中指向的内 存取指令井执行，它不知道什么是操作系统，也无需知道。","keywords":["uCore","天问之路"],"articleBody":"01操作系统是是什么 社会组织和人们之间的关系，正是操作系统和用户进程的关系\n当人们想和远方的朋友说话时，虽然可以徒步走到亲朋好友身边再对其表达想说的话，但社会组织 已经给提供了邮局和电话，何必自己再大老远跑一趟呢。这就是操作系统（社会组织）提供的资源。两 个人想在一起生活，要不要一定先结婚呢？完全不用，领不领证都不会阻碍人们在一起生活，但是社会 组织为了方便人口管理做了额外约束。不领证的话，至少社会组织无法预测未来人口数量趋势，无法做 出宏观调控，甚至这是找到你家人的一种方法。这就如 Linux 系统中的内存管理，分别要记录哪些页是 Active，哪些是“脏页“。不记录不会影响程序执行，记录这些状态还不是为了更好地管理 内存。\n03写操作系统，哪些需要我来做 操作系统是管理资源的软件，操作系统能做什么，取决于主机上硬件的功能。\n写操作系统需要了解硬件，这些硬件提供了软件方面的接口，这样我们的操作系统通过软件（计算机指令〉就能够控制硬件。我们需要做的就是知道如何通过计算机指令来控制硬件，参考硬件手册这下少不了啦。\n04软件是如何访问硬件的 各种硬件适配设备，这就是 IO 接口。接口其实就是标准，大家生产出来的硬件按照这个标准工作就实现了通用。\n访问外部硬件有两个方式。\n（1）将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 lMB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。\n(2)外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递 给另一端的外设，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看， 处处体现着分层。 于是问题来了，如何访问到 IO 接口呢，答案就是 IO 接口上面有一些寄存器，访问 IO 接口本质上就是 访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口 。 人家接口 电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。接口提供接口，哈哈，有意思。 不过这是人家的约定，没有约定就乱了，各干各的，大家都累，咱们只要遵循人家的规定就能访问成功。\n05应用程序是什么，和操作系统是如何配合到一起的 应用程序和操作系统都是软件。 CPU 会将它们一视同仁，甚至， CPU 不知道自己在执行的程序是操作系统，还是一般应用软件， CPU 只知道去 CS: ip 寄存器中指向的内 存取指令井执行，它不知道什么是操作系统，也无需知道。\n应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是编译 器。是编译器决定怎样解释某种关键字及某种语法。 语言只是编译器和大家的约定，只要写入这样的代码， 编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为，和语言无关，比如说 C 语言的 printf 函数，它的功能不是说一定要把字符打印到屏幕上，这要看编译器对这种关键字的处理。\n编译器提供了一套库函数，库函数中又有封装的系统调用，这样的代码集合称之为运行库。 C 语言的 运行库称为 C 运行库，就是所谓的 CRT ( C Runtime Library ）。\n应用程序加上操作系统提供功能才算是完整的程序。由于有了操作系统的支持，一些现成的东西己经摆 在那了，但这些是属于操作系统的，不是应用程序的，所以咱们平时所写的应用程序只是半成品，需要调用操作系统提供好的函数才能完整地做成一件事，而这个函数便是系统调用。\n用户态与内核态是对 CPU 来讲的，是指 CPU 运行在用户态（特权 3 级）还是内核态（特权 0 级）， 很多人误以为是对用户进程来讲的。\n用户进程陷入内核态是指 ：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的 中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户代码 怎么可能在内核中存在，所以“用户态与内核态”是对 CPU 来说的。\n当应用程序陆入内核后，它自己已经下 CPU 了，以后发生的事，应用程序完全不知道，它的上下文环境己 经被保存到自己的 0 特权级技中了，那时在 CPU 上运行的程序己经是内核程序了。所以要清楚，内核代码并不 是成了应用程序的内核化身，操作系统是独立的部分，用户进程永远不会因为进入内核态而变身为操作系统了。\n应用程序是通过系统调用来和操作系统配合完成某项功能的，有人可能会问：我写应用程序时从来没 写什么系统调用的代码啊。这是因为你用到的标准库帮你完成了这些事，库中提供的函数其实都已经封装 好了系统调用，你需要跟下代码才会看到 。 其实也可以跨过标准库直接执行系统调用，对于 Linux 系统来 说，直接嵌入汇编代码“ int 0x80”便可以直接执行系统调用，-当然要提前设置好系统调用子功能号，该子功能号用寄存器 eax存储。\n会不会有人又问，编译器怎么知道系统调用接口是什么，哈哈，您想啊，下载编译器时，是不是要选择系 统版本，编译器在设计时也要知道自己将来运行在哪个系统平台上，所以这都是和系统绑定好的，各个操作系 统都有自己的系统调用号，编译器厂商在代码中已经把宿主系统的系统调用号写死了，没什么神奇的。\n06 为什么称陷入内核 如果把软件分层的话， 最外圈是应用程序，里面是操作系统，如图 0-1 所示 。 应用程序处于特权级 3，操作系统内核处于特权级 0。当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调 用。这样 CPU 便进入了内核态，也称管态 。 看图中凹下去的部分，是不 是有陆进去的感觉，这就是“陷入内核”。\n07内存访问为什么要分段 只要程序分了段，把整个段平移到任何位置后，段内的地址相对于段基址是不变的，无论段基址是多少，只要给出段内偏移地址， CPU 就能访问到正确的指令。于是加载用户 程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无 误地运行，因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址处的内存内容还是一样的，如图 0-3 所示。\n程序分段首先是为了重定位。 偏移地址也要存入寄存器，而那时的寄存器是 16 位的，也就 是一个段最多可以访问到 64阻。而那时的内存再小也有 IMB, 改变段基址，由一个段变为另一个段，就像一个段在内存中飘移， 采用这种在内存中来回挪位置的方式可以访问到任意内存位直。程序分段又是为了将大内存分成可以访问的小段， 通过这样变通的方法便能够访问到所有内存了。\n08 代码中为什么分为代码段，数据段？这和内存访问机制中的段是一回事吗 内存分段指的是处理器为访问内存而采用的机制，称之为内存分段机制，程序分段是软件中人为逻辑划分的内存区域，它本身也是内存，所以处理器在访问该区域时，也会采用内存分段机制，用段寄存器指向该区域的起始地址。\n程序不是一定要分段才能运行的，分段只是为了使程序更加优美 。\nx86 平台的处理器是必须要用分段机制访问内存的，正因为如此，处理器才提供了段寄存器，用来指定待访 问的内存段起始地址。我们这里讨论的程序代码中的段（用 section 或 segment 来定义的段，不同汇编编译器提 供的关键字有所区别，功能是一样的）和内存访问机制中的段本质上是一回事。 在硬件的内存访问机制中，处理 器要用硬件一一段寄存器，指向软件一一程序代码中用 section 或 segment 以软件形式所定义的内存段。\n分段是必然的，只是在平坦模型下，硬件段寄存器中指向的内存段为最大的 4GB ，而在多段模式下编 程，硬件段寄存器中指向的内存段大小不一 。\n对于目前咱们 用高级语言编码来说，我们之所以不用关心如何将程序分段，正是由于编译器按平坦模型编译，而程序所 依赖的操作系统又采用了虚拟内存管理，即处理器的分页机制。像汇编这种低级语言允许程序员为 自 己的 程序分段，能够灵活地编排布局，这就属于人为将程序分成段了，也就是采用多段模型编程 。\n将数据和代码分开的好处有三点。\n第一，可以为它们赋予不同的属性。\n例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。真要是运行过程中程序的下一条指令被修改了，谁知道会产生什么样的灾难。\n第二，为了提高 CPU 内部缓存的命中率。\n缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令 和数据分离，这有利于增强程序的局部性。 CPU 内部有针对数据和针对指令的两种缓存机制，因此，将 数据和代码分开存储将使程序运行得更快。\n第三，节省内存。\n程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时（比如同时执行多个 ls 命令时），没必要在内存中同时存在多个相同的代码段，这将浪费有限的物理内存资源，只要把这一个代 码段共享就可以了。\n在保护模式下，有这样一个数据结构，它叫全局描述符表（ Global Descriptor Table, GDT），这个表中的每一项称为段描述符。先递归学习一下，什么是描述符？描述符就是描 述某种数据的数据结构，是元信息，属于数据的数据。就像人们的身份证，上面有写性别、出生日期、地址等 描述个人情况的信息。在段描述符中有段的属性位，在以后的章节中可以看到，其实是有 2 个，一个是 S 宇 段，占 1bit 大小，另外一个是占 4bit 大小的 TYPE 宇段，这两个宇段配合在一起使用就能组合出各种属性， 如只读、向下扩展、只执行等。提供归提供，可得有人去填写这张表啊，谁来做这事呢，有请操作系统登场。 接着看操作系统为我们做了什么。\n操作系统在让 CPU 进入保护模式之前，首先要准备好 GDT，也就是要设置好 GDT 的相关项，填写好 段描述符。段描述符填写成什么样，段具备什么样的属性，这完全取决于操作系统了，在这里大家只要知道， 段描述符中的 S 宇段和 TYPE 宇段负责该段的属性，也就是该属性与安全相关。\n（1）编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的 代码段和可写属性的数据段。再补充一下，编译器并没有让段具备某种属性，对于代码段，编译器所做的 只是将代码归类到一起而己，也就是将程序中的有关代码的多个 section 合并成一个大的 segment （这就是 我们所说的代码段〉，它并没有为代码段添加额外的信息。\n(2 ）操作系统通过设置 GOT 全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属 性（包括 S 宇段和 TYPE 字段）。也就是说，操作系统认为代码应该是只读的，所以给用来指向代码段的 那个段描述符设置了只读的属性，这才是真正给段添加属性的地方。\n(3) CPU 中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其 理解为相当于段基址〉，从而确定了指向的段。在执行指令时，会根据该段的属性来判断指令的行为，若 有返回则发出异常。 总之，编译器、操作系统、 CPU 三个配合在一起才能对程序保护，检测出指令中的违规行为。如果 GDT 中的代码段描述符具备可写的属性，那编译器再怎么划分代码段都没有用，有判断权利的只有 CPU 。\n编译器编译出来的段和内存访问中的段是一回事吗？\n程序中的段只是逻辑上的划分，用于不同数据的归类， 但是可以用 CPU 中的段寄存器直接指向它们，然后用内存分段机制去访问程序中的段，在这一点上看，它们很像相片和相框的关系：程序中的段是内存中的内容，相当于相片，属于被展示的内容，而内存分段机制则是访问内存的手段，相当于相框，有了相框，照片才能有地摆放 。\n09物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别 物理地址就是物理内存真正的地址，具有唯一性。不管在什么模式下， 不管什么虚拟地址、线性地址， CPU 最终都要以物理地址去访问内存。\n在实模式下，“段基址＋段内偏移地址”经过段部件的处理，直接输出的就是物理地址， CPU 可以直接用此地址访问内存 。\n而在保护模式下，＂段基址＋段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址 了，而是一个称为选择子的东西 。 它本质是个索引，类似于数组下标，通过这个索引便能在 GDT 中找到相应 的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能， 此线性地址就被当作物理地址来用，可直接访问内存。 若开启了分页功能，此线性地址又多了一个名字，就是 虚拟地址 （虚拟地址、线性地址在分页机制下都是一回事） 。 虚拟地址要经过 CPU 页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线去访问内存。 无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址，这是程序员可见的地址 。 这是因为，最终的地址是由段基址和段内偏移地址组合而成的。由于段基址已经有默认的啦，要么是在实模式下的默认段寄存器中，要么是在保护模式下的默认段选择子寄存器指向的段描述 符中，所以只要给出段内偏移地址就行了，这个地址虽然只是段内偏移，但加上默认的段基址，依然足够有效 。\n线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间 。 由于分页功能是需要在保护模式下开启的， 32 位系统保护模式下的寻址空间是 4GB，所以虚拟地址或线性地 址就是 0～4GB 的范围 。 转换过程如图 0-5 所示 。\n10什么是段重叠 假设在实模式下（并不是说在保护模式下就不存在段重叠，只是这样就会少解释了相关数据结构， 如段描述符，不过这不重要，原理是一样的）， 一个段最大为 64kb，其大小由段内偏移地址寻址范围决定， 也就是 2 的 16 次方 。 其起始位置由段基地址决定。 CPU 的内存寻址方式是：给我一个段基址，再给我一 个相对于该段起始位置的偏移地址，我就能访问到相应内存 。 它并不要求一个内存地址只隶属于某一个段，所以在上面的 图 0-2 中，欲访问内存 0xC03 ，段基址可以选择 0xC00, 0xC01, 0xC02, 0xC03 ，只不过是段内偏移量要根据段基地址来调整罢了 。 用这种“段基地址：段内偏移”的组合， 0xC00: 3 和 0xC02: 1 是等价的，它们都访问到同一个物理内存块 。 但段的大小决定于段内偏移地址寻址范围，假设段 A 的段基址是 从 0xC00开始，段 B 的段基址是从 0xC02 开始，在 16 位宽 段A 度的寻址范围内，这两个段都能访问到 0xC05 这块内存。用 段 A 去访问，其偏移为 5，用段 B 去访问，其偏移量为 3 。 这样一来，用段 B 和段 A 在地址 OxC02 之后， 一直到段 B 偏移地址为 0xfffe 的部分，像是重叠在一起了，这就是段重叠了，如图 0-6 所示 。\n11什么是平坦模型 平坦模型是相对于多段模型来说的，所以说平坦模型指的就是一个段 。\n12cs、ds、这类srog段寄存器，位宽是多少 在 32 位 CPU 中，sreg 段寄存器都是 16 位宽。\nCPU 中存在段寄存器是因为其内存是分段访问的。\nCPU 内部的段寄存器（ Segment reg ）如下。 (1) CS - 代码段寄存器（ Code Segment Register），其值为代码段的段基值 。\n(2) DS - 数据段寄存器（ Data Segment Register），其值为数据段的段基值。 (3) ES－附加段寄存器（ Extra Segment Register），其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。 (4) FS - 附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，同上，用途不固定，使用上灵活机动。 (5) GS - 附加段寄存器（ Extra Segment Register），其值为附加数据段的段基值。 (6) SS - 堆栈段寄存器（ Stack Segment Register），其值为堆栈段的段值。\n32 位 CPU 有两种不同的工作模式：实模式和保护模式。\n每种模式下，段寄存器中值的意义是不同的，但不管其为何值，在段寄存器中所表达的都是指向的段在哪里。在实模式下， cs 、 DS 、 ES 、 SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子” C Selector), 当然，选择子也是数值，其依然为 16 位宽度。\n可见，在 32 位 CPU 中， sreg 无论是工作在 16 位的实模式，还是 32 位的保护模式，用的段寄存器都 是同一组，并且在 32 位下的段选择子是 16 位宽度，排除了段寄存器在 32 位环境下是 32 位宽的可能，综上所述， sreg 都是 16 位宽。\n13什么是工程，什么是协议 软件中的工程是指开发一套软件所需要的全部文件，包含实际代码和环境配置。\n协议是一种大家共同遵守的规约，主要用来实现通信、共享、协作：起初是为避免大家各干各的，无法彼此调用对方成果的情况，从而给大家统一一种接口、一组数据调用或者分析的约定。\n14为什么Linux下的应用程序不能在Windows下运行   格式不同\nLinux 下的可执行程序格式是 elf （Executable and Linking Format ）\n​\tWindows 下的可执行程序是 PE 格式（ portable executable，可移植的可执行文件）\n  系统API不同\nLinux 中的可执行程序获得系统资源的方法和 Windows 不一样。\nLinux 中的 API 称为系统调用，是通过 int 0x80。这个软中断实现的。\n而 Windows 中的 API 是存放在动态链接库文件（ DLL，Dynamic Link Library）中。DLL 是 一个库，里面包含代码和数据，可供用户程序调用， DLL 不是可执行文件，不能够单独运行。\n  除以上原因外，还和编译器、标准库有关，不再列举。\n  15局部变量和函数参数为什么要放在栈中 全局变量：意味着谁都可以随时随地访问，所以其放在数据段中。\n局部变量：只是自己在用，放在数据段中纯属琅费空间，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。这个就是堆栈框架，提到了就说一点吧，栈由于是向下生长的，堆栈框架就是把 esp 指针提前加一个数，原 esp 指针到新 esp 指针之间的栈空间用来存储局部变量。\n解释一个概念，堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程 规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。\n堆是堆，而堆栈就是栈，和堆没关系，只是都这么叫。栈和堆栈都是指的栈，在 C程序的内存布局中，由于 堆和栈的地址空间是接壤的，栈从高地址往低地址发展，堆是从低地址往高地址发展，堆和栈早晚会碰头，它们各自的大小取决于实际的使用情况，界限并不明朗，所以这可能是堆栈常放在一直称呼的原因吧。\n函数参数为什么会放到栈区呢？\n第一也是其局部性导致的，只有这个函数用这个参数，何必将其放在数据段呢 。\n第二 ，因为函数是在程序执行过程中调用的，属于动态的调用，编译时无法预测会何时调用及被调用的次数，函数的参数及返回值都需要内存来存储，不知道需要多少内存 。即使编译器可以预测，那提前准备好内存也是一种浪费。所以编译器选择在每次调用函数时才为它在栈中分配内存。\n16为什么说汇编语言比C语言快 首先说这是谬论，汇编语言编译器编译出来的机器指令和 C 编译器编译出来的机器指令无异。\n但高级语言如 C 语言为了通用性等，加入了一些额外的代码， 因此编译出来的汇编代码比较多，不如用汇编语言直接 写功能相关的部分效果来得更直接， C 语言被编译成机器指令后， 相当于多执行了一些“看似没用”的指令，因此会比直接用汇编语言慢。\n","wordCount":"585","inLanguage":"en","datePublished":"2021-06-20T00:00:00Z","dateModified":"2021-06-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://1nten.github.io//post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"intenのblog🍦","logo":{"@type":"ImageObject","url":"https://1nten.github.io//favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://1nten.github.io// accesskey=h title="intenのblog🍦 (Alt + H)">intenのblog🍦</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://1nten.github.io//archives title=Archive><span>Archive</span></a></li><li><a href=https://1nten.github.io//search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://1nten.github.io//tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>操作系统真象还原笔记</h1><div class=post-meta>June 20, 2021&nbsp;·&nbsp;3 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#01%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%98%af%e6%98%af%e4%bb%80%e4%b9%88 aria-label=01操作系统是是什么>01操作系统是是什么</a></li><li><a href=#03%e5%86%99%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%93%aa%e4%ba%9b%e9%9c%80%e8%a6%81%e6%88%91%e6%9d%a5%e5%81%9a aria-label=03写操作系统，哪些需要我来做>03写操作系统，哪些需要我来做</a></li><li><a href=#04%e8%bd%af%e4%bb%b6%e6%98%af%e5%a6%82%e4%bd%95%e8%ae%bf%e9%97%ae%e7%a1%ac%e4%bb%b6%e7%9a%84 aria-label=04软件是如何访问硬件的>04软件是如何访问硬件的</a></li><li><a href=#05%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e6%98%af%e4%bb%80%e4%b9%88%e5%92%8c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%98%af%e5%a6%82%e4%bd%95%e9%85%8d%e5%90%88%e5%88%b0%e4%b8%80%e8%b5%b7%e7%9a%84 aria-label=05应用程序是什么，和操作系统是如何配合到一起的>05应用程序是什么，和操作系统是如何配合到一起的</a></li><li><a href=#06-%e4%b8%ba%e4%bb%80%e4%b9%88%e7%a7%b0%e9%99%b7%e5%85%a5%e5%86%85%e6%a0%b8 aria-label="06 为什么称陷入内核">06 为什么称陷入内核</a></li><li><a href=#07%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%88%86%e6%ae%b5 aria-label=07内存访问为什么要分段>07内存访问为什么要分段</a></li><li><a href=#08-%e4%bb%a3%e7%a0%81%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e5%88%86%e4%b8%ba%e4%bb%a3%e7%a0%81%e6%ae%b5%e6%95%b0%e6%8d%ae%e6%ae%b5%e8%bf%99%e5%92%8c%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e6%9c%ba%e5%88%b6%e4%b8%ad%e7%9a%84%e6%ae%b5%e6%98%af%e4%b8%80%e5%9b%9e%e4%ba%8b%e5%90%97 aria-label="08 代码中为什么分为代码段，数据段？这和内存访问机制中的段是一回事吗">08 代码中为什么分为代码段，数据段？这和内存访问机制中的段是一回事吗</a></li><li><a href=#09%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e9%80%bb%e8%be%91%e5%9c%b0%e5%9d%80%e6%9c%89%e6%95%88%e5%9c%b0%e5%9d%80%e7%ba%bf%e6%80%a7%e5%9c%b0%e5%9d%80%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=09物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别>09物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</a></li><li><a href=#10%e4%bb%80%e4%b9%88%e6%98%af%e6%ae%b5%e9%87%8d%e5%8f%a0 aria-label=10什么是段重叠>10什么是段重叠</a></li><li><a href=#11%e4%bb%80%e4%b9%88%e6%98%af%e5%b9%b3%e5%9d%a6%e6%a8%a1%e5%9e%8b aria-label=11什么是平坦模型>11什么是平坦模型</a></li><li><a href=#12csds%e8%bf%99%e7%b1%bbsrog%e6%ae%b5%e5%af%84%e5%ad%98%e5%99%a8%e4%bd%8d%e5%ae%bd%e6%98%af%e5%a4%9a%e5%b0%91 aria-label=12cs、ds、这类srog段寄存器，位宽是多少>12cs、ds、这类srog段寄存器，位宽是多少</a></li><li><a href=#13%e4%bb%80%e4%b9%88%e6%98%af%e5%b7%a5%e7%a8%8b%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%8f%e8%ae%ae aria-label=13什么是工程，什么是协议>13什么是工程，什么是协议</a></li><li><a href=#14%e4%b8%ba%e4%bb%80%e4%b9%88linux%e4%b8%8b%e7%9a%84%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8d%e8%83%bd%e5%9c%a8windows%e4%b8%8b%e8%bf%90%e8%a1%8c aria-label=14为什么Linux下的应用程序不能在Windows下运行>14为什么Linux下的应用程序不能在Windows下运行</a></li><li><a href=#15%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%92%8c%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%94%be%e5%9c%a8%e6%a0%88%e4%b8%ad aria-label=15局部变量和函数参数为什么要放在栈中>15局部变量和函数参数为什么要放在栈中</a></li><li><a href=#16%e4%b8%ba%e4%bb%80%e4%b9%88%e8%af%b4%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e6%af%94c%e8%af%ad%e8%a8%80%e5%bf%ab aria-label=16为什么说汇编语言比C语言快>16为什么说汇编语言比C语言快</a></li></ul></div></details></div><div class=post-content><h3 id=01操作系统是是什么>01操作系统是是什么<a hidden class=anchor aria-hidden=true href=#01操作系统是是什么>#</a></h3><p><strong>社会组织和人们之间的关系，正是操作系统和用户进程的关系</strong></p><p>当人们想和远方的朋友说话时，虽然可以徒步走到亲朋好友身边再对其表达想说的话，但社会组织 已经给提供了邮局和电话，何必自己再大老远跑一趟呢。这就是操作系统（社会组织）提供的资源。两 个人想在一起生活，要不要一定先结婚呢？完全不用，领不领证都不会阻碍人们在一起生活，但是社会 组织为了方便人口管理做了额外约束。不领证的话，至少社会组织无法预测未来人口数量趋势，无法做 出宏观调控，甚至这是找到你家人的一种方法。这就如 Linux 系统中的内存管理，分别要记录哪些页是 Active，哪些是“脏页“。不记录不会影响程序执行，记录这些状态还不是为了更好地管理 内存。</p><h3 id=03写操作系统哪些需要我来做>03写操作系统，哪些需要我来做<a hidden class=anchor aria-hidden=true href=#03写操作系统哪些需要我来做>#</a></h3><p>操作系统是管理资源的软件，操作系统能做什么，取决于主机上硬件的功能。</p><p>写操作系统需要了解硬件，这些硬件提供了软件方面的接口，这样我们的操作系统通过软件（计算机指令〉就能够控制硬件。我们需要做的就是知道如何通过计算机指令来控制硬件，参考硬件手册这下少不了啦。</p><h3 id=04软件是如何访问硬件的>04软件是如何访问硬件的<a hidden class=anchor aria-hidden=true href=#04软件是如何访问硬件的>#</a></h3><p>各种硬件适配设备，这就是 <strong>IO 接口</strong>。接口其实就是标准，大家生产出来的硬件按照这个标准工作就实现了通用。</p><p>访问外部硬件有两个方式。</p><p>（1）<strong>将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中</strong>，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 lMB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。</p><p>(2)<strong>外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递 给另一端的外设</strong>，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看， 处处体现着分层。 于是问题来了，如何访问到 IO 接口呢，答案就是 IO 接口上面有一些寄存器，访问 IO 接口本质上就是 访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口 。 人家接口 电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。接口提供接口，哈哈，有意思。 不过这是人家的约定，没有约定就乱了，各干各的，大家都累，咱们只要遵循人家的规定就能访问成功。</p><h3 id=05应用程序是什么和操作系统是如何配合到一起的>05应用程序是什么，和操作系统是如何配合到一起的<a hidden class=anchor aria-hidden=true href=#05应用程序是什么和操作系统是如何配合到一起的>#</a></h3><p>应用程序和操作系统都是软件。 CPU 会将它们一视同仁，甚至， CPU 不知道自己在执行的程序是操作系统，还是一般应用软件， CPU 只知道去 CS: ip 寄存器中指向的内 存取指令井执行，它不知道什么是操作系统，也无需知道。</p><p>应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是编译 器。是编译器决定怎样解释某种关键字及某种语法。 语言只是编译器和大家的约定，只要写入这样的代码， 编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为，和语言无关，比如说 C 语言的 printf 函数，它的功能不是说一定要把字符打印到屏幕上，这要看编译器对这种关键字的处理。</p><p>编译器提供了一套库函数，库函数中又有封装的系统调用，这样的代码集合称之为运行库。 C 语言的 运行库称为 C 运行库，就是所谓的 CRT ( C Runtime Library ）。</p><p><strong>应用程序加上操作系统提供功能才算是完整的程序。<strong>由于有了操作系统的支持，一些现成的东西己经摆 在那了，但这些是属于操作系统的，不是应用程序的，所以咱们平时所写的应用程序只是半成品，需要调用操作系统提供好的函数才能完整地做成一件事，而这个函数便是</strong>系统调用</strong>。</p><p><strong>用户态与内核态</strong>是对 CPU 来讲的，是指 CPU 运行在用户态（特权 3 级）还是内核态（特权 0 级）， 很多人误以为是对用户进程来讲的。</p><p>用户进程陷入内核态是指 ：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的 中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户代码 怎么可能在内核中存在，所以“用户态与内核态”是对 CPU 来说的。</p><p>当应用程序陆入内核后，它自己已经下 CPU 了，以后发生的事，应用程序完全不知道，它的上下文环境己 经被保存到自己的 0 特权级技中了，那时在 CPU 上运行的程序己经是内核程序了。所以要清楚，内核代码并不 是成了应用程序的内核化身，操作系统是独立的部分，用户进程永远不会因为进入内核态而变身为操作系统了。</p><p>应用程序是通过系统调用来和操作系统配合完成某项功能的，有人可能会问：我写应用程序时从来没 写什么系统调用的代码啊。这是因为你用到的标准库帮你完成了这些事，库中提供的函数其实都已经封装 好了系统调用，你需要跟下代码才会看到 。 其实也可以跨过标准库直接执行系统调用，对于 Linux 系统来 说，直接嵌入汇编代码“ int 0x80”便可以直接执行系统调用，-当然要提前设置好系统调用子功能号，该子功能号用寄存器 eax存储。</p><p>会不会有人又问，编译器怎么知道系统调用接口是什么，哈哈，您想啊，下载编译器时，是不是要选择系 统版本，编译器在设计时也要知道自己将来运行在哪个系统平台上，所以这都是和系统绑定好的，各个操作系 统都有自己的系统调用号，编译器厂商在代码中已经把宿主系统的系统调用号写死了，没什么神奇的。</p><h3 id=06-为什么称陷入内核>06 为什么称陷入内核<a hidden class=anchor aria-hidden=true href=#06-为什么称陷入内核>#</a></h3><p>如果把软件分层的话， 最外圈是应用程序，里面是操作系统，如图 0-1 所示 。 应用程序处于特权级 3，操作系统内核处于特权级 0。当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调 用。这样 CPU 便进入了内核态，也称管态 。 看图中凹下去的部分，是不 是有陆进去的感觉，这就是“陷入内核”。</p><p><img loading=lazy src=https://www.kro1lsec.com:442/images/2021/06/21/20210621152154.png alt=image-20210615210325917></p><h3 id=07内存访问为什么要分段>07内存访问为什么要分段<a hidden class=anchor aria-hidden=true href=#07内存访问为什么要分段>#</a></h3><p>只要程序分了段，把整个段平移到任何位置后，段内的地址相对于段基址是不变的，无论段基址是多少，只要给出段内偏移地址， CPU 就能访问到正确的指令。于是加载用户 程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无 误地运行，因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址处的内存内容还是一样的，如图 0-3 所示。</p><p></p><p><strong>程序分段首先是为了重定位</strong>。 偏移地址也要存入寄存器，而那时的寄存器是 16 位的，也就 是一个段最多可以访问到 64阻。而那时的内存再小也有 IMB, 改变段基址，由一个段变为另一个段，就像一个段在内存中飘移， 采用这种在内存中来回挪位置的方式可以访问到任意内存位直。程序分段又<strong>是为了将大内存分成可以访问的小段</strong>， 通过这样变通的方法便能够访问到所有内存了。</p><h3 id=08-代码中为什么分为代码段数据段这和内存访问机制中的段是一回事吗>08 代码中为什么分为代码段，数据段？这和内存访问机制中的段是一回事吗<a hidden class=anchor aria-hidden=true href=#08-代码中为什么分为代码段数据段这和内存访问机制中的段是一回事吗>#</a></h3><p><strong>内存分段指的是处理器为访问内存而采用的机制，称之为内存分段机制，程序分段是软件中人为逻辑划分的内存区域，它本身也是内存，所以处理器在访问该区域时，也会采用内存分段机制，用段寄存器指向该区域的起始地址。</strong></p><p>程序不是一定要分段才能运行的，分段只是为了使程序更加优美 。</p><p>x86 平台的处理器是必须要用分段机制访问内存的，正因为如此，处理器才提供了段寄存器，用来指定待访 问的内存段起始地址。我们这里讨论的程序代码中的段（用 section 或 segment 来定义的段，不同汇编编译器提 供的关键字有所区别，功能是一样的）和内存访问机制中的段本质上是一回事。 在硬件的内存访问机制中，处理 器要用硬件一一段寄存器，指向软件一一程序代码中用 section 或 segment 以软件形式所定义的内存段。</p><p>分段是必然的，只是在平坦模型下，硬件段寄存器中指向的内存段为最大的 4GB ，而在多段模式下编 程，硬件段寄存器中指向的内存段大小不一 。</p><p>对于目前咱们 用高级语言编码来说，我们之所以不用关心如何将程序分段，正是由于编译器按平坦模型编译，而程序所 依赖的操作系统又采用了虚拟内存管理，即处理器的分页机制。像汇编这种低级语言允许程序员为 自 己的 程序分段，能够灵活地编排布局，这就属于人为将程序分成段了，也就是采用多段模型编程 。</p><p>将数据和代码分开的好处有三点。</p><p>第一，可以为它们赋予不同的属性。</p><p>例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。真要是运行过程中程序的下一条指令被修改了，谁知道会产生什么样的灾难。</p><p>第二，为了提高 CPU 内部缓存的命中率。</p><p>缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令 和数据分离，这有利于增强程序的局部性。 CPU 内部有针对数据和针对指令的两种缓存机制，因此，将 数据和代码分开存储将使程序运行得更快。</p><p>第三，节省内存。</p><p>程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时（比如同时执行多个 ls 命令时），没必要在内存中同时存在多个相同的代码段，这将浪费有限的物理内存资源，只要把这一个代 码段共享就可以了。</p><p>在保护模式下，有这样一个数据结构，它叫全局描述符表（ Global Descriptor Table, GDT），这个表中的每一项称为段描述符。先递归学习一下，什么是描述符？描述符就是描 述某种数据的数据结构，是元信息，属于数据的数据。就像人们的身份证，上面有写性别、出生日期、地址等 描述个人情况的信息。在段描述符中有段的属性位，在以后的章节中可以看到，其实是有 2 个，一个是 S 宇 段，占 1bit 大小，另外一个是占 4bit 大小的 TYPE 宇段，这两个宇段配合在一起使用就能组合出各种属性， 如只读、向下扩展、只执行等。提供归提供，可得有人去填写这张表啊，谁来做这事呢，有请操作系统登场。 接着看操作系统为我们做了什么。</p><p>操作系统在让 CPU 进入保护模式之前，首先要准备好 GDT，也就是要设置好 GDT 的相关项，填写好 段描述符。段描述符填写成什么样，段具备什么样的属性，这完全取决于操作系统了，在这里大家只要知道， 段描述符中的 S 宇段和 TYPE 宇段负责该段的属性，也就是该属性与安全相关。</p><p>（1）编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的 代码段和可写属性的数据段。再补充一下，编译器并没有让段具备某种属性，对于代码段，编译器所做的 只是将代码归类到一起而己，也就是将程序中的有关代码的多个 section 合并成一个大的 segment （这就是 我们所说的代码段〉，它并没有为代码段添加额外的信息。</p><p>(2 ）操作系统通过设置 GOT 全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属 性（包括 S 宇段和 TYPE 字段）。也就是说，操作系统认为代码应该是只读的，所以给用来指向代码段的 那个段描述符设置了只读的属性，这才是真正给段添加属性的地方。</p><p>(3) CPU 中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其 理解为相当于段基址〉，从而确定了指向的段。在执行指令时，会根据该段的属性来判断指令的行为，若 有返回则发出异常。 总之，编译器、操作系统、 CPU 三个配合在一起才能对程序保护，检测出指令中的违规行为。如果 GDT 中的代码段描述符具备可写的属性，那编译器再怎么划分代码段都没有用，有判断权利的只有 CPU 。</p><p><strong>编译器编译出来的段和内存访问中的段是一回事吗？</strong></p><p>程序中的段只是逻辑上的划分，用于不同数据的归类， 但是可以用 CPU 中的段寄存器直接指向它们，然后用内存分段机制去访问程序中的段，在这一点上看，它们很像相片和相框的关系：程序中的段是内存中的内容，相当于相片，属于被展示的内容，而内存分段机制则是访问内存的手段，相当于相框，有了相框，照片才能有地摆放 。</p><h3 id=09物理地址逻辑地址有效地址线性地址虚拟地址的区别>09物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别<a hidden class=anchor aria-hidden=true href=#09物理地址逻辑地址有效地址线性地址虚拟地址的区别>#</a></h3><p><strong>物理地址就是物理内存真正的地址</strong>，具有唯一性。不管在什么模式下， 不管什么虚拟地址、线性地址， CPU 最终都要以物理地址去访问内存。</p><p>在<strong>实模式</strong>下，“段基址＋段内偏移地址”经过段部件的处理，直接输出的就是物理地址， CPU 可以直接用此地址访问内存 。</p><p>而在<strong>保护模式</strong>下，＂段基址＋段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址 了，而是一个称为选择子的东西 。 它本质是个索引，类似于数组下标，通过这个索引便能在 GDT 中找到相应 的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能， 此线性地址就被当作物理地址来用，可直接访问内存。 若开启了分页功能，此<strong>线性地址</strong>又多了一个名字，就是 <strong>虚拟地址</strong> （虚拟地址、线性地址在分页机制下都是一回事） 。 虚拟地址要经过 CPU 页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线去访问内存。 无论在实模式或是保护模式下，<strong>段内偏移地址又称为有效地址，也称为逻辑地址</strong>，这是程序员可见的地址 。 这是因为，最终的地址是由段基址和段内偏移地址组合而成的。由于段基址已经有默认的啦，要么是在实模式下的默认段寄存器中，要么是在保护模式下的默认段选择子寄存器指向的段描述 符中，所以只要给出段内偏移地址就行了，这个地址虽然只是段内偏移，但加上默认的段基址，依然足够有效 。</p><p>线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间 。 由于分页功能是需要在保护模式下开启的， 32 位系统保护模式下的寻址空间是 4GB，所以虚拟地址或线性地 址就是 0～4GB 的范围 。 转换过程如图 0-5 所示 。</p><p><img loading=lazy src=https://www.kro1lsec.com:442/images/2021/06/21/20210621152205.png alt=image-20210616154921006></p><h3 id=10什么是段重叠>10什么是段重叠<a hidden class=anchor aria-hidden=true href=#10什么是段重叠>#</a></h3><p>假设在实模式下（并不是说在保护模式下就不存在段重叠，只是这样就会少解释了相关数据结构， 如段描述符，不过这不重要，原理是一样的）， 一个段最大为 64kb，其大小由段内偏移地址寻址范围决定， 也就是 2 的 16 次方 。 其起始位置由段基地址决定。 <strong>CPU 的内存寻址方式</strong>是：给我一个段基址，再给我一 个相对于该段起始位置的偏移地址，我就能访问到相应内存 。 它并不要求一个内存地址只隶属于某一个段，所以在上面的 图 0-2 中，欲访问内存 0xC03 ，段基址可以选择 0xC00, 0xC01, 0xC02, 0xC03 ，只不过是段内偏移量要根据段基地址来调整罢了 。 用这种“段基地址：段内偏移”的组合， 0xC00: 3 和 0xC02: 1 是等价的，它们都访问到同一个物理内存块 。 但段的大小决定于段内偏移地址寻址范围，假设段 A 的段基址是 从 0xC00开始，段 B 的段基址是从 0xC02 开始，在 16 位宽 段A 度的寻址范围内，这两个段都能访问到 0xC05 这块内存。用 段 A 去访问，其偏移为 5，用段 B 去访问，其偏移量为 3 。 这样一来，用段 B 和段 A 在地址 OxC02 之后， 一直到段 B 偏移地址为 0xfffe 的部分，像是重叠在一起了，这就是段重叠了，如图 0-6 所示 。</p><p><img loading=lazy src=https://www.kro1lsec.com:442/images/2021/06/21/20210621152210.png alt=image-20210616155642795></p><h3 id=11什么是平坦模型>11什么是平坦模型<a hidden class=anchor aria-hidden=true href=#11什么是平坦模型>#</a></h3><p>平坦模型是相对于多段模型来说的，所以说平坦模型指的就是一个段 。</p><h3 id=12csds这类srog段寄存器位宽是多少>12cs、ds、这类srog段寄存器，位宽是多少<a hidden class=anchor aria-hidden=true href=#12csds这类srog段寄存器位宽是多少>#</a></h3><p>在 32 位 CPU 中，<strong>sreg 段寄存器都是 16 位宽</strong>。</p><p>CPU 中存在段寄存器是因为其内存是分段访问的。</p><p>CPU 内部的段寄存器（ Segment reg ）如下。
(1) CS - 代码段寄存器（ Code Segment Register），其值为代码段的段基值 。</p><p>(2) DS - 数据段寄存器（ Data Segment Register），其值为数据段的段基值。
(3) ES－附加段寄存器（ Extra Segment Register），其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。
(4) FS - 附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，同上，用途不固定，使用上灵活机动。
(5) GS - 附加段寄存器（ Extra Segment Register），其值为附加数据段的段基值。
(6) SS - 堆栈段寄存器（ Stack Segment Register），其值为堆栈段的段值。</p><p>32 位 CPU 有两种不同的工作模式：实模式和保护模式。</p><p>每种模式下，段寄存器中值的意义是不同的，但不管其为何值，在段寄存器中所表达的都是指向的段在哪里。在实模式下， cs 、 DS 、 ES 、 SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子” C Selector), 当然，选择子也是数值，其依然为 16 位宽度。</p><p>可见，在 32 位 CPU 中， sreg 无论是工作在 16 位的实模式，还是 32 位的保护模式，用的段寄存器都 是同一组，并且在 32 位下的段选择子是 16 位宽度，排除了段寄存器在 32 位环境下是 32 位宽的可能，综上所述， sreg 都是 16 位宽。</p><h3 id=13什么是工程什么是协议>13什么是工程，什么是协议<a hidden class=anchor aria-hidden=true href=#13什么是工程什么是协议>#</a></h3><p>软件中的工程是指开发一套软件所需要的全部文件，包含实际代码和环境配置。</p><p>协议是一种大家共同遵守的规约，主要用来实现通信、共享、协作：起初是为避免大家各干各的，无法彼此调用对方成果的情况，从而给大家统一一种接口、一组数据调用或者分析的约定。</p><h3 id=14为什么linux下的应用程序不能在windows下运行>14为什么Linux下的应用程序不能在Windows下运行<a hidden class=anchor aria-hidden=true href=#14为什么linux下的应用程序不能在windows下运行>#</a></h3><ul><li><p><strong>格式不同</strong></p><p>Linux 下的可执行程序格式是 elf （Executable and Linking Format ）</p><p>​ Windows 下的可执行程序是 PE 格式（ portable executable，可移植的可执行文件）</p></li><li><p><strong>系统API不同</strong></p><p>Linux 中的可执行程序获得系统资源的方法和 Windows 不一样。</p><p>Linux 中的 API 称为系统调用，是通过 int 0x80。这个软中断实现的。</p><p>而 Windows 中的 API 是存放在动态链接库文件（ DLL，Dynamic Link Library）中。DLL 是 一个库，里面包含代码和数据，可供用户程序调用， DLL 不是可执行文件，不能够单独运行。</p></li><li><p>除以上原因外，还和<strong>编译器</strong>、<strong>标准库</strong>有关，不再列举。</p></li></ul><h3 id=15局部变量和函数参数为什么要放在栈中>15局部变量和函数参数为什么要放在栈中<a hidden class=anchor aria-hidden=true href=#15局部变量和函数参数为什么要放在栈中>#</a></h3><p><strong>全局变量</strong>：意味着谁都可以随时随地访问，所以其放在数据段中。</p><p><strong>局部变量</strong>：只是自己在用，放在数据段中纯属琅费空间，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。这个就是<strong>堆栈框架</strong>，提到了就说一点吧，栈由于是向下生长的，堆栈框架就是把 esp 指针提前加一个数，原 esp 指针到新 esp 指针之间的栈空间用来存储局部变量。</p><p>解释一个概念，堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程 规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。</p><p>堆是堆，而堆栈就是栈，和堆没关系，只是都这么叫。栈和堆栈都是指的栈，在 C程序的内存布局中，由于 堆和栈的地址空间是接壤的，栈从高地址往低地址发展，堆是从低地址往高地址发展，堆和栈早晚会碰头，它们各自的大小取决于实际的使用情况，界限并不明朗，所以这可能是堆栈常放在一直称呼的原因吧。</p><p><strong>函数参数为什么会放到栈区呢</strong>？</p><p>第一也是其局部性导致的，只有这个函数用这个参数，何必将其放在数据段呢 。</p><p>第二 ，因为函数是在程序执行过程中调用的，属于动态的调用，编译时无法预测会何时调用及被调用的次数，函数的参数及返回值都需要内存来存储，不知道需要多少内存 。即使编译器可以预测，那提前准备好内存也是一种浪费。所以编译器选择在每次调用函数时才为它在栈中分配内存。</p><h3 id=16为什么说汇编语言比c语言快>16为什么说汇编语言比C语言快<a hidden class=anchor aria-hidden=true href=#16为什么说汇编语言比c语言快>#</a></h3><p>首先说这是谬论，汇编语言编译器编译出来的机器指令和 C 编译器编译出来的机器指令无异。</p><p>但高级语言如 C 语言为了通用性等，加入了一些额外的代码， 因此编译出来的汇编代码比较多，不如用汇编语言直接 写功能相关的部分效果来得更直接， C 语言被编译成机器指令后， 相当于多执行了一些“看似没用”的指令，因此会比直接用汇编语言慢。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://1nten.github.io//tags/ucore/>uCore</a></li><li><a href=https://1nten.github.io//tags/%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF/>天问之路</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统真象还原笔记 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9c%9f%e8%b1%a1%e8%bf%98%e5%8e%9f%e7%ac%94%e8%ae%b0&url=https%3a%2f%2finten.kro1lsec.com%2fpost%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%259C%259F%25E8%25B1%25A1%25E8%25BF%2598%25E5%258E%259F%25E7%25AC%2594%25E8%25AE%25B0%2f&hashtags=uCore%2c%e5%a4%a9%e9%97%ae%e4%b9%8b%e8%b7%af"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统真象还原笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2finten.kro1lsec.com%2fpost%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%259C%259F%25E8%25B1%25A1%25E8%25BF%2598%25E5%258E%259F%25E7%25AC%2594%25E8%25AE%25B0%2f&title=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9c%9f%e8%b1%a1%e8%bf%98%e5%8e%9f%e7%ac%94%e8%ae%b0&summary=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9c%9f%e8%b1%a1%e8%bf%98%e5%8e%9f%e7%ac%94%e8%ae%b0&source=https%3a%2f%2finten.kro1lsec.com%2fpost%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%259C%259F%25E8%25B1%25A1%25E8%25BF%2598%25E5%258E%259F%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统真象还原笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2finten.kro1lsec.com%2fpost%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%259C%259F%25E8%25B1%25A1%25E8%25BF%2598%25E5%258E%259F%25E7%25AC%2594%25E8%25AE%25B0%2f&title=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9c%9f%e8%b1%a1%e8%bf%98%e5%8e%9f%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统真象还原笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2finten.kro1lsec.com%2fpost%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%259C%259F%25E8%25B1%25A1%25E8%25BF%2598%25E5%258E%259F%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统真象还原笔记 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9c%9f%e8%b1%a1%e8%bf%98%e5%8e%9f%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2finten.kro1lsec.com%2fpost%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%259C%259F%25E8%25B1%25A1%25E8%25BF%2598%25E5%258E%259F%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统真象还原笔记 on telegram" href="https://telegram.me/share/url?text=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9c%9f%e8%b1%a1%e8%bf%98%e5%8e%9f%e7%ac%94%e8%ae%b0&url=https%3a%2f%2finten.kro1lsec.com%2fpost%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%259C%259F%25E8%25B1%25A1%25E8%25BF%2598%25E5%258E%259F%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://1nten.github.io//>intenのblog🍦</a></span>
<span>&#183;</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const d=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function c(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),c();return}const a=document.createRange();a.selectNodeContents(b);const d=window.getSelection();d.removeAllRanges(),d.addRange(a);try{document.execCommand('copy'),c()}catch(a){}d.removeRange(a)}),d.appendChild(a)})</script></body></html>